import os
import unittest

import numpy as np
import scipy as sp
from mpi4py import MPI

from tacs import TACS, pytacs

"""
Test matrix-vector multiplication operations for TACSSchurMat and TACSParallelMat.

Uses the I_beam.bdf mesh to create a realistic stiffness matrix, then compares
TACS mult and multTranspose operations against reference results computed by scipy

The reference results can be generated by running this file directly rather than via unittest
"""

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
BDF_FILE = os.path.join(BASE_DIR, "./input_files/I_beam.bdf")
VEC_FILE = os.path.join(BASE_DIR, "./input_files/I_beam_x_ref.txt")
PROD_FILE = os.path.join(BASE_DIR, "./input_files/I_beam_Kx_ref.txt")
TRANSPOSE_PROD_FILE = os.path.join(BASE_DIR, "./input_files/I_beam_KTx_ref.txt")

def globalToLocalArray(globalArray, assembler):
    """Given an array containing values for all nodes in the original order, get an array containing the values for the nodes on this proc, in the reordered order.

    Parameters
    ----------
    globalArray : numpy array (either 1D with length numNodes*N or 2D with shape (numNodes, N))
        Array containing values for all nodes in the original order.
    assembler : tacs.pyTACS
        pyTACS assembler object.

    Returns
    -------
    numpy array (1D with length numLocalNodes*N)
        Array containing values for the nodes on this proc, in the reordered order.
    """
    numNodes = assembler.meshLoader.getNumBDFNodes()
    globalArray = globalArray.reshape((numNodes, -1))
    varsPerNode = globalArray.shape[1]
    globalToLocalMap = assembler.meshLoader.getGlobalToLocalNodeIDDict()
    globalIDs = np.array(list(globalToLocalMap.keys()), dtype=int)
    localIDs = np.array(list(globalToLocalMap.values()), dtype=int)
    numLocalnodes = len(localIDs)
    localArray = np.zeros((numLocalnodes, varsPerNode), dtype=globalArray.dtype)
    localArray[localIDs, :] = globalArray[globalIDs, :]
    return localArray.flatten()

def localToGlobalArray(localArray, assembler):
    """Given an array containing values for the nodes on this proc, in the reordered order, get an array containing values for all nodes in the original order.

    Parameters
    ----------
    localArray : numpy array (either 1D with length numLocalNodes*N or 2D with shape (numLocalNodes, N))
        Array containing values for the nodes on this proc, in the reordered order.
    assembler : tacs.pyTACS
        pyTACS assembler object.

    Returns
    -------
    numpy array (1D with length numNodes*N)
        Array containing values for all nodes in the original order.
    """
    numNodes = assembler.meshLoader.getNumBDFNodes()
    numLocalnodes = assembler.getNumOwnedNodes()
    localArray = localArray.reshape((numLocalnodes, -1))
    varsPerNode = localArray.shape[1]
    globalToLocalMap = assembler.meshLoader.getGlobalToLocalNodeIDDict()
    globalIDs = np.array(list(globalToLocalMap.keys()), dtype=int)
    localIDs = np.array(list(globalToLocalMap.values()), dtype=int)
    globalArray = np.zeros((numNodes, varsPerNode), dtype=localArray.dtype)
    globalArray[globalIDs, :] = localArray[localIDs, :]

    # Sum the arrays across all procs ao that every proc has the full global array
    assembler.comm.Allreduce(MPI.IN_PLACE, globalArray, op=MPI.SUM)

    return globalArray.flatten()

def setupMatrices(bdfFile, comm):
    """Set up TACS matrices from BDF file.

    Parameters
    ----------
    bdfFile : str
        Path to BDF file.
    comm : MPI.Comm
        MPI communicator.

    Returns
    -------
    assembler : tacs.pyTACS
        pyTACS assembler object.
    schurMat : tacs.TACSSchurMat
        Assembled TACSSchurMat object.
    parallelMat : tacs.TACSParallelMat
        Assembled TACSParallelMat object.
    """
    FEAAssembler = pytacs.pyTACS(bdfFile, comm)
    FEAAssembler.initialize()

    # Create a static problem (needed to set up vars)
    static_probs = FEAAssembler.createTACSProbsFromBDF()
    problem = list(static_probs.values())[0]

    # Set up assembler vars
    problem._updateAssemblerVars()

    assembler = FEAAssembler.assembler

    # Create both matrix types
    schur_mat = assembler.createSchurMat()
    parallel_mat = assembler.createMat()

    # Assemble Jacobian into both matrices
    assembler.assembleJacobian(1.0, 0.0, 0.0, None, schur_mat)
    assembler.assembleJacobian(1.0, 0.0, 0.0, None, parallel_mat)

    return FEAAssembler, schur_mat, parallel_mat

def getXVec(size):
    """Generate a deterministic random vector of given size."""
    np.random.seed(42)
    x = np.random.rand(size).astype(TACS.dtype)
    return x

class MatrixOperationsTest(unittest.TestCase):
    """
    Test TACS matrix-vector operations against scipy reference.

    Strategy:
    1. Load pre-computed scipy reference matrix from file on all ranks
    2. Set up parallel TACS problem and assemble matrices
    3. Compare TACS mult/multTranspose against scipy @ x
    """

    N_PROCS = 2

    def setUp(self):
        self.comm = MPI.COMM_WORLD
        self.rank = self.comm.rank
        self.dtype = TACS.dtype

        # Tolerances for comparison
        self.rtol = 1e-10
        self.atol = 1e-10

        # Set up TACS matrices
        self.assembler, self.schur_mat, self.parallel_mat = setupMatrices(BDF_FILE, self.comm)

        # Read the reference results
        xRef = np.loadtxt(VEC_FILE).astype(self.dtype)
        self.KxRef = np.loadtxt(PROD_FILE).astype(self.dtype)
        self.KTxRef = np.loadtxt(TRANSPOSE_PROD_FILE).astype(self.dtype)

        # Set the reference input values into a TACS vector
        self.xVec = self.assembler.createVec(asBVec=True)
        self.xVec.getArray()[:] = globalToLocalArray(xRef, self.assembler)

    def compareResults(self, y, yRef, name):
        np.testing.assert_allclose(
            y,
            yRef,
            rtol=self.rtol,
            atol=self.atol,
            err_msg=f"{name} failed on rank {self.rank}",
        )

    def templateTest(self, mat, testName, transpose=False):
        yRef = self.KTxRef if transpose else self.KxRef

        # Compute TACS result
        y = self.assembler.createVec(asBVec=True)
        if transpose:
            mat.multTranspose(self.xVec, y)
        else:
            mat.mult(self.xVec, y)

        self.compareResults(y.getArray(), globalToLocalArray(yRef, self.assembler), testName)

    def test_schur_mat_mult(self):
        """Test TACSSchurMat.mult against scipy matrix-vector product."""
        self.templateTest(self.schur_mat, "SchurMat.mult", transpose=False)

    def test_schur_mat_mult_transpose(self):
        """Test TACSSchurMat.multTranspose against scipy transpose product."""
        self.templateTest(self.schur_mat, "SchurMat.multTranspose", transpose=True)

    def test_parallel_mat_mult(self):
        """Test TACSParallelMat.mult against scipy matrix-vector product."""
        self.templateTest(self.parallel_mat, "ParallelMat.mult", transpose=False)

    def test_parallel_mat_mult_transpose(self):
        """Test TACSParallelMat.multTranspose against scipy transpose product."""
        self.templateTest(self.parallel_mat, "ParallelMat.multTranspose", transpose=True)


if __name__ == "__main__":
    # In serial, create TACS matrix, extract it as a scipy matrix, compute reference mat-vec results and save them
    comm = MPI.COMM_WORLD
    colour = 0 if comm.rank == 0 else MPI.UNDEFINED
    subComm = comm.Split(color=colour, key=0)
    if subComm != MPI.COMM_NULL:
        assembler, schur_mat, parallel_mat = setupMatrices(BDF_FILE, subComm)
        scipyParMat = sp.sparse.coo_array(parallel_mat.getMat()[0])
        scipyParMat.eliminate_zeros()
        x = getXVec(scipyParMat.shape[0])
        xReordered = globalToLocalArray(x, assembler)
        KxRef = scipyParMat @ xReordered
        KTxRef = scipyParMat.T @ xReordered
        # Undo the TACS reordering of the products
        KxRef = localToGlobalArray(KxRef, assembler)
        KTxRef = localToGlobalArray(KTxRef, assembler)
        # Save the reference results
        numFormat = "%.16e"
        np.savetxt("input_files/I_beam_x_ref.txt", x, fmt=numFormat)
        np.savetxt("input_files/I_beam_Kx_ref.txt", KxRef, fmt=numFormat)
        np.savetxt("input_files/I_beam_KTx_ref.txt", KTxRef, fmt=numFormat)
