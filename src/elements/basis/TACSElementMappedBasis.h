/*
  This file is part of TACS: The Toolkit for the Analysis of Composite
  Structures, a parallel finite-element code for structural and
  multidisciplinary design optimization.

  Copyright (C) 2014 Georgia Tech Research Corporation

  TACS is licensed under the Apache License, Version 2.0 (the
  "License"); you may not use this software except in compliance with
  the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0
*/

#ifndef TACS_ELEMENT_MAPPED_BASIS_H
#define TACS_ELEMENT_MAPPED_BASIS_H

#include "TACSElementBasis.h"

/*
  This virtual base class defines the interface for the basis functions
  and quadrature schemes used in most TACS elements.

  These are designed to provide common quadrature, interpolation, and
  transformation computations needed for finite element computations.
  This is also designed to capture
*/

class TACSElementMappedBasis : public TACSElementBasis {
 public:
  /**
    Get the face normal at a specified face quadrature point.

    This function returns a 2 or 3-vector depending on the dimension
    of the problem. Note that this function can only be used to evaluate
    the face normal at locations defined by the basis function class.

    @param face The face/edge index
    @param n The quadrautre point index
    @param Xpts The node locations
    @param Xd The derivative of the physical node location w.r.t. parameters
    @param normal The face (or edge) normal
    @return The area contribution
  */
  virtual TacsScalar getFaceNormal(int face, int n, const TacsScalar Xpts[],
                                   TacsScalar X[], TacsScalar Xd[],
                                   TacsScalar normal[]);

  /**
    Add the derivative of the face normal into the nodal sensitivities

    @param face The face/edge index
    @param n The quadrautre point index
    @param Xpts The node locations
    @param A The area contribution (computed from forward code)
    @param normal The face normal
    @param dfdA The input derivative of the function w.r.t. area
    @param dfdXd The derivative of the function w.r.t. Xd
    @param dfdn The derivative of the function w.r.t. surface normal
    @param dfdXpts The output derivative w.r.t. the node locations
  */
  virtual void addFaceNormalXptSens(
      int face, int n, const TacsScalar A, const TacsScalar Xd[],
      const TacsScalar normal[], const TacsScalar dfdA, const TacsScalar dfdX[],
      const TacsScalar dfdXd[], const TacsScalar dfdn[], TacsScalar dfdXpts[]);

  /**
    Get the Jacobian transformation from computational to physical
    coordinates.

    This code returns the determinant of the transformation and
    returns both the Xd, the derivative of physical coordinates
    w.r.t. the parameters, and J, the inverse of Xd. This code can be
    used for computing the volume/area quadratures.

    @param n The quadrautre point index
    @param pt The quadrature point
    @param Xpts The node locations
    @param Xd The derivative of the physical node location w.r.t. parameters
    @param J The Jacobian transformation (inverse of Xd)
    @return The determinant of Xd
  */
  virtual TacsScalar getJacobianTransform(int n, const double pt[],
                                          const TacsScalar Xpts[],
                                          TacsScalar Xd[], TacsScalar J[]);

  /**
    Compute the derivative of the Jacobian transformation

    This code adds the contribution to the derivative of the Jacobian
    transformation to the output dfdXpts. Note that the inputs here
    should be generated by a call to getJacobianTransform first.  Note
    that dfdXd and dfdJ may be passed as NULL.

    @param pt The quadrature point
    @param Xpts The node locations
    @param Xd The derivative of the physical node location w.r.t. parameters
    @param J The Jacobian transformation (inverse of Xd)
    @param dfddetJ The derivative of the function w.r.t. detJ
    @param dfdXd The derivative of the function w.r.t. Xd
    @param dfdJ The derivative of the function w.r.t. J
    @param dfdXpts The output derivative of the function w.r.t. Xpts
  */
  virtual void addJacobianTransformXptSens(
      int n, const double pt[], const TacsScalar Xd[], const TacsScalar J[],
      TacsScalar dfddetJ, const TacsScalar dfXd[], const TacsScalar dfdJ[],
      TacsScalar dfdXpts[]);

 protected:
  static TacsScalar computeMappedFaceNormal(
      const int num_params, const int num_nodes, const double N[],
      const double Nxi[], const TacsScalar Xpts[], const double tangents[],
      TacsScalar X[], TacsScalar Xd[], TacsScalar n[]);
  static TacsScalar computeMappedJacobianTransform(
      const int num_params, const int num_nodes, const double Nxi[],
      const TacsScalar Xpts[], TacsScalar Xd[], TacsScalar J[]);
};

#endif  // TACS_ELEMENT_MAPPED_BASIS_H
