
<!DOCTYPE html>

<html lang="python">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tacs.pytacs &#8212; TACS  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinxdoc.css" />
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">TACS  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">tacs.pytacs</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for tacs.pytacs</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">pytacs - The Python wrapper for the TACS assembler</span>

<span class="sd">This python interface is designed to provide a easier interface to the</span>
<span class="sd">C++ layer of TACS. User-supplied hooks allow for nearly complete</span>
<span class="sd">customization of any or all parts of the problem setup. There are two</span>
<span class="sd">main parts of this module: The first deals with setting up the TACS</span>
<span class="sd">model including reading the mesh, setting elements and design variables.</span>
<span class="sd">The second part deals with creating problem instances that are responsible</span>
<span class="sd">for setting loads and functions, performing analysis, and gradient computations.</span>

<span class="sd">Developers:</span>
<span class="sd">    - Dr. G.K.W. Kenway (GKK)</span>
<span class="sd">    - Dr. T.R Brooks</span>

<span class="sd">History:</span>
<span class="sd">    - v. 1.0 pyTACS initial implementation</span>
<span class="sd">    - v. 3.0 updated TACS 3.0 pyTACS implementation</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># =============================================================================</span>
<span class="c1"># Imports</span>
<span class="c1"># =============================================================================</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">tacs.TACS</span><span class="o">,</span> <span class="nn">tacs.constitutive</span><span class="o">,</span> <span class="nn">tacs.elements</span><span class="o">,</span> <span class="nn">tacs.functions</span><span class="o">,</span> <span class="nn">tacs.problems.static</span>
<span class="kn">from</span> <span class="nn">.utilities</span> <span class="kn">import</span> <span class="n">BaseUI</span>
<span class="kn">from</span> <span class="nn">tacs.pymeshloader</span> <span class="kn">import</span> <span class="n">pyMeshLoader</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="pyTACS"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS">[docs]</a><span class="k">class</span> <span class="nc">pyTACS</span><span class="p">(</span><span class="n">BaseUI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The class for working with a TACS structure</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Default class options</span>
    <span class="n">defaultOptions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># Meshloader options</span>
        <span class="s2">&quot;printDebug&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">bool</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;Flag for whether to print debug information while loading file.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="c1"># Output Options</span>
        <span class="s2">&quot;outputElement&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">int</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;Specifies which element type should be written out in the f5 file.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> If None, the type will be inferred from the first element in the model.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> Acceptable values are:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.ELEMENT_NONE = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">ELEMENT_NONE</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.SCALAR_2D_ELEMENT = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">SCALAR_2D_ELEMENT</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.SCALAR_3D_ELEMENT = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">SCALAR_3D_ELEMENT</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.BEAM_OR_SHELL_ELEMENT = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">BEAM_OR_SHELL_ELEMENT</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.PLANE_STRESS_ELEMENT = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">PLANE_STRESS_ELEMENT</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.SOLID_ELEMENT = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">SOLID_ELEMENT</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.RIGID_ELEMENT = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">RIGID_ELEMENT</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.MASS_ELEMENT = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">MASS_ELEMENT</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.SPRING_ELEMENT = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">SPRING_ELEMENT</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.PCM_ELEMENT = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">PCM_ELEMENT</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;writeConnectivity&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">bool</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;Flag for whether to include element connectivity in f5 file.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;writeNodes&quot;</span><span class="p">:</span> <span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;Flag for whether to include nodes in f5 file.&quot;</span><span class="p">],</span>
        <span class="s2">&quot;writeDisplacements&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">bool</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;Flag for whether to include nodal displacements in f5 file.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;writeStrains&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">bool</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;Flag for whether to include element strains in f5 file.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;writeStresses&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">bool</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;Flag for whether to include element stresses in f5 file.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;writeExtras&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">bool</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;Flag for whether to include element extra variables in f5 file.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;writeCoordinateFrame&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">bool</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;Flag for whether to include element coordinate frames in f5 file.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;familySeparator&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">str</span><span class="p">,</span>
            <span class="s2">&quot;/&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Family separator character used for condensing groups in f5 file.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;printTiming&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">bool</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;Flag for printing out timing information for class procedures.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dvNum</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scaleList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fileName : str</span>
<span class="sd">            The filename of the BDF file to load.</span>

<span class="sd">        comm : mpi4py.MPI.Intracomm</span>
<span class="sd">            The comm object on which to create the pyTACS object.</span>

<span class="sd">        dvNum : int</span>
<span class="sd">            An user supplied offset to the design variable</span>
<span class="sd">            numbering. This is typically used with tacs+tripan when</span>
<span class="sd">            geometric variables have already been added and assigned</span>
<span class="sd">            global tacs numberings.</span>

<span class="sd">        scaleList: list</span>
<span class="sd">            when dvNum is non zero, the scaleList must be same size</span>
<span class="sd">            as the number of design variables already added. i.e.</span>
<span class="sd">            len(scaleList) = dvNum</span>

<span class="sd">        options : dict</span>
<span class="sd">            Dictionary holding model-specific option parameters (case-insensitive).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">startTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># Set the communicator and rank -- defaults to MPI_COMM_WORLD</span>
        <span class="k">if</span> <span class="n">comm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="o">=</span> <span class="n">comm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">rank</span>

        <span class="c1"># Process the default options which are added to self.options</span>
        <span class="c1"># under the &#39;defaults&#39; key. Make sure the key are lower case</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">def_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultOptions</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;defaults&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">def_keys</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;defaults&quot;</span><span class="p">][</span><span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultOptions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultOptions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># Process the user-supplied options</span>
        <span class="n">userOptions</span> <span class="o">=</span> <span class="n">options</span>
        <span class="n">optKeys</span> <span class="o">=</span> <span class="n">userOptions</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">optKeys</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setOption</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">userOptions</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="n">importTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># Create and load mesh loader object.</span>
        <span class="n">debugFlag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;printDebug&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span> <span class="o">=</span> <span class="n">pyMeshLoader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span> <span class="n">debugFlag</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">scanBdfFile</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bdfName</span> <span class="o">=</span> <span class="n">fileName</span>
        <span class="c1"># Save pynastran bdf object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getBDFInfo</span><span class="p">()</span>

        <span class="n">meshLoadTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># Retrieve the number of components. This is the maximum</span>
        <span class="c1"># number of unique constitutive objects possible in this model.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nComp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getNumComponents</span><span class="p">()</span>

        <span class="c1"># Load all the component descriptions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compDescripts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getComponentDescripts</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elemDescripts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getElementDescripts</span><span class="p">()</span>

        <span class="c1"># Set the starting dvNum and scaleList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span> <span class="o">=</span> <span class="n">dvNum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaleList</span> <span class="o">=</span> <span class="n">scaleList</span>
        <span class="k">if</span> <span class="n">scaleList</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scaleList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">DVPreprocTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># List of DV groups</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">globalDVs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compIDBounds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addedCompIDs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># List of initial coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xpts0</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># List of initial designvars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Variables per node for model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">varsPerNode</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># TACS assembler object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">initFinishTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;printTiming&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span><span class="s2">&quot;+--------------------------------------------------+&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span><span class="s2">&quot;| TACS Init Times:&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span>
                <span class="s2">&quot;| </span><span class="si">%-30s</span><span class="s2">: </span><span class="si">%10.3f</span><span class="s2"> sec&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;TACS Module Time&quot;</span><span class="p">,</span> <span class="n">importTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span>
                <span class="s2">&quot;| </span><span class="si">%-30s</span><span class="s2">: </span><span class="si">%10.3f</span><span class="s2"> sec&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;TACS Meshload Time&quot;</span><span class="p">,</span> <span class="n">meshLoadTime</span> <span class="o">-</span> <span class="n">importTime</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span>
                <span class="s2">&quot;| </span><span class="si">%-30s</span><span class="s2">: </span><span class="si">%10.3f</span><span class="s2"> sec&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;TACS DV Processing Time&quot;</span><span class="p">,</span> <span class="n">DVPreprocTime</span> <span class="o">-</span> <span class="n">meshLoadTime</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span>
                <span class="s2">&quot;| </span><span class="si">%-30s</span><span class="s2">: </span><span class="si">%10.3f</span><span class="s2"> sec&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;TACS Finalize Initialization Time&quot;</span><span class="p">,</span> <span class="n">initFinishTime</span> <span class="o">-</span> <span class="n">DVPreprocTime</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span>
                <span class="s2">&quot;| </span><span class="si">%-30s</span><span class="s2">: </span><span class="si">%10.3f</span><span class="s2"> sec&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;TACS Total Initialization Time&quot;</span><span class="p">,</span> <span class="n">initFinishTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span><span class="s2">&quot;+--------------------------------------------------+&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="pyTACS.addGlobalDV"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.addGlobalDV">[docs]</a>    <span class="k">def</span> <span class="nf">addGlobalDV</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">descript</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function allows adding design variables that are not</span>
<span class="sd">        cleanly associated with a particular constitutive object. One</span>
<span class="sd">        example is the pitch of the stiffeners for blade stiffened</span>
<span class="sd">        panels; It often is the same for many different constitutive</span>
<span class="sd">        objects. By calling this function, the internal dvNum counter</span>
<span class="sd">        is incremented and the user doesn\&#39;t have to worry about</span>
<span class="sd">        it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        descript : str</span>
<span class="sd">            A user supplied string that can be used to retrieve the</span>
<span class="sd">            variable number and value elemCallBackFunction.</span>

<span class="sd">        value : float</span>
<span class="sd">            Initial value for variable.</span>
<span class="sd">        lower : float</span>
<span class="sd">            Lower bound. May be None for unbounded</span>
<span class="sd">        upper : float</span>
<span class="sd">            Upper bound. May be None for unbounded</span>
<span class="sd">        scale : float</span>
<span class="sd">            Scale factor for variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">globalDVs</span><span class="p">[</span><span class="n">descript</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;num&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span><span class="p">,</span>
            <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span>
            <span class="s2">&quot;lowerBound&quot;</span><span class="p">:</span> <span class="n">lower</span><span class="p">,</span>
            <span class="s2">&quot;upperBound&quot;</span><span class="p">:</span> <span class="n">upper</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaleList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span></div>

<div class="viewcode-block" id="pyTACS.selectCompIDs"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.selectCompIDs">[docs]</a>    <span class="k">def</span> <span class="nf">selectCompIDs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">include</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">includeBounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nGroup</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">includeOp</span><span class="o">=</span><span class="s2">&quot;or&quot;</span><span class="p">,</span>
        <span class="n">excludeOp</span><span class="o">=</span><span class="s2">&quot;or&quot;</span><span class="p">,</span>
        <span class="n">projectVector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the most important function of the entire setup</span>
<span class="sd">        process. The basic idea is as follow: We have a list of nComp</span>
<span class="sd">        which are the component descriptions. What we need is a way of</span>
<span class="sd">        generating subgroups of these for the purposes of adding</span>
<span class="sd">        design variables, constitutive objects, KS domains and mass</span>
<span class="sd">        domains. All of these operations boil down to selecting a</span>
<span class="sd">        subset of the compIDs.</span>

<span class="sd">        This function attempts to support as many ways as possible to</span>
<span class="sd">        select parts of the structure. Easy and efficient selection of</span>
<span class="sd">        parts is critical to the end user.</span>

<span class="sd">        Methods of selection:</span>

<span class="sd">        1. include, integer, string, list of integers and/or strings: The</span>
<span class="sd">           simplest and most direct way of selecting a component. The</span>
<span class="sd">           user supplies the index of the componentID, a name or partial</span>
<span class="sd">           name, or a list of a combination of both.</span>

<span class="sd">           For example::</span>

<span class="sd">            # Select the 11th component</span>
<span class="sd">            selectCompIDs(include=10)</span>

<span class="sd">            # Select the first and fifth component</span>
<span class="sd">            selectCompIDs(include=[0, 4])</span>

<span class="sd">            # Select any component containing &#39;rib.00&#39;</span>
<span class="sd">            selectCompIDs(include=&#39;rib.00&#39;)</span>

<span class="sd">            # Select any components containing &#39;rib.00&#39; and &#39;rib.10&#39;</span>
<span class="sd">            selectCompIDs(include=[&#39;rib.00&#39;, &#39;rib.10&#39;])</span>

<span class="sd">            # Select any component containing &#39;rib.00&#39;, the 11th</span>
<span class="sd">            # component and any component containing &#39;spar&#39;</span>
<span class="sd">            # (This is probably not advisable!)</span>
<span class="sd">            selectCompIDs(include=[&#39;rib.00&#39;, 10, &#39;spar&#39;])</span>

<span class="sd">        2. Exclude, operates similarly to &#39;include&#39;. The behaviour</span>
<span class="sd">           of exclude is identical to include above, except that</span>
<span class="sd">           component ID&#39;s that are found using &#39;exclude&#39; are</span>
<span class="sd">           &#39;subtracted&#39; from those found using include. A special</span>
<span class="sd">           case is treated if &#39;include&#39; is NOT given: if only an</span>
<span class="sd">           exclude list is given, this implies the selection of all</span>
<span class="sd">           compID&#39;s EXCEPT the those in exclude.</span>

<span class="sd">           For example::</span>

<span class="sd">               # This will return will [0, 1, 2, 3, 5, ..., nComp-1]</span>
<span class="sd">               selectCompIDs(exclude = 4)</span>

<span class="sd">               # This will return [0, 1, 4, 5, ..., nComp-1]</span>
<span class="sd">               selectCompIDs(exclude = [2, 3]) will return</span>

<span class="sd">               # This will return components that have &#39;ribs&#39; in the</span>
<span class="sd">               # component ID, but not those that have &#39;le_ribs&#39; in the</span>
<span class="sd">               # component id.</span>
<span class="sd">               selectCompIDs(include=&#39;ribs&#39;, exclude=&#39;le_ribs&#39;)</span>

<span class="sd">        3. includeBounds, list of components defining a region inside</span>
<span class="sd">           of which &#39;include&#39; components will be selected. This</span>
<span class="sd">           functionality uses a geometric approach to select the compIDs.</span>
<span class="sd">           All components within the project 2D convex hull are included.</span>
<span class="sd">           Therefore it is essential to split up concave include regions</span>
<span class="sd">           into smaller convex regions. Use multiple calls to selectCompIDs to</span>
<span class="sd">           accumulate multiple regions.</span>

<span class="sd">           For example::</span>

<span class="sd">               # This will select upper skin components between the</span>
<span class="sd">               # leading and trailing edge spars and between ribs 1 and 4.</span>
<span class="sd">               selectCompIDs(include=&#39;U_SKIN&#39;, includeBound=</span>
<span class="sd">                   [&#39;LE_SPAR&#39;, &#39;TE_SPAR&#39;, &#39;RIB.01&#39;, &#39;RIB.04&#39;])</span>

<span class="sd">        4. nGroup: The number of groups to divide the found componets</span>
<span class="sd">           into. Generally this will be 1. However, in certain cases, it</span>
<span class="sd">           is convenient to create multiple groups in one pass.</span>

<span class="sd">           For example::</span>

<span class="sd">             # This will &#39;evenly&#39; create 10 groups on all components</span>
<span class="sd">             # containing LE_SPAR. Note that once the componets are</span>
<span class="sd">             # selected, they are sorted **alphabetically** and assigned</span>
<span class="sd">             # sequentially.</span>
<span class="sd">             selectCompIDs(include=&#39;LE_SPAR&#39;, nGroup=10)</span>

<span class="sd">           nGroup can also be negative. If it is negative, then a single</span>
<span class="sd">           design variable group is added to each of the found</span>
<span class="sd">           components.</span>

<span class="sd">           For example::</span>

<span class="sd">             # will select all components and assign a design variable</span>
<span class="sd">             # group to each one.</span>
<span class="sd">             selectCompIDs(nGroup=-1)</span>

<span class="sd">        includeOp, str: &#39;and&#39; or &#39;or&#39;. Selects the logical operation</span>
<span class="sd">        used for item in &#39;include&#39; option. For example:</span>

<span class="sd">        selectCompIDs(include=[&#39;LE_SPAR&#39;, &#39;TE_SPAR&#39;],</span>
<span class="sd">        includeOpt=&#39;or&#39;) will select the LE_SPAR and TE_SPAR</span>
<span class="sd">        components (default behaviour).</span>

<span class="sd">        selectCompIDs(include=[&#39;RIB&#39;, &#39;SEG.01&#39;], includeOpt=&#39;and&#39;)</span>
<span class="sd">        will select any component with &#39;RIB&#39; in the description AND</span>
<span class="sd">        &#39;SEG.01&#39; in the description.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Defaults</span>
        <span class="n">includeIDs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="p">)</span>
        <span class="n">excludeIDs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">includeBoundIDs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">include</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">includeIDs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getCompIDs</span><span class="p">(</span><span class="n">includeOp</span><span class="p">,</span> <span class="n">include</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">excludeIDs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getCompIDs</span><span class="p">(</span><span class="n">excludeOp</span><span class="p">,</span> <span class="n">exclude</span><span class="p">)</span>

        <span class="n">iSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">includeIDs</span><span class="p">)</span>
        <span class="n">eSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">excludeIDs</span><span class="p">)</span>

        <span class="c1"># First take the intersection of iSet and ibSet</span>
        <span class="k">if</span> <span class="n">includeBoundIDs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">iSet</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">includeBoundIDs</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">iSet</span>

        <span class="c1"># Next take the difference between tmp and eSet</span>
        <span class="n">compIDs</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">eSet</span><span class="p">)</span>

        <span class="c1"># Convert back to a list:</span>
        <span class="n">compIDs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">compIDs</span><span class="p">)</span>

        <span class="c1"># If we only want a single group, we&#39;re done, otherwise, we</span>
        <span class="c1"># have a bit more work to do...</span>
        <span class="k">if</span> <span class="n">nGroup</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># The user wants to have nGroups returned from compIDs.</span>

            <span class="c1"># First check that nGroup &lt;= len(compIDs), print warning</span>
            <span class="c1"># and clip if not</span>
            <span class="k">if</span> <span class="n">nGroup</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">compIDs</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_TACSWarning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;nGroup=</span><span class="si">{</span><span class="n">nGroup</span><span class="si">}</span><span class="s2"> is larger than the number of</span><span class="se">\</span>
<span class="s2">                selected components=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">compIDs</span><span class="p">)</span><span class="si">}</span><span class="s2">. nGroup will be clipped to </span><span class="si">{</span><span class="n">nGroup</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">nGroup</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">compIDs</span><span class="p">)</span>

            <span class="c1"># Pluck out the component descriptions again and we will</span>
            <span class="c1"># sort them</span>
            <span class="n">compDescript</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">compIDs</span><span class="p">)):</span>
                <span class="n">compDescript</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compDescripts</span><span class="p">[</span><span class="n">compIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

            <span class="c1"># define a general argsort</span>
            <span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="n">seq</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">)</span>

            <span class="c1"># ind is the index that would result in a sorted list.</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">compDescript</span><span class="p">)</span>

            <span class="c1"># Now simply divide &#39;ind&#39; into &#39;nGroups&#39; as evenly as</span>
            <span class="c1"># possible, in the integer sense.</span>
            <span class="k">def</span> <span class="nf">split_list</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span> <span class="n">wanted_parts</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">[</span>
                    <span class="n">alist</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">length</span> <span class="o">//</span> <span class="n">wanted_parts</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">length</span> <span class="o">//</span> <span class="n">wanted_parts</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wanted_parts</span><span class="p">)</span>
                <span class="p">]</span>

            <span class="n">ind</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">nGroup</span><span class="p">)</span>

            <span class="c1"># Finally assemble the nested list of component IDs</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)):</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                    <span class="n">tmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compIDs</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]])</span>
            <span class="n">compIDs</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">elif</span> <span class="n">nGroup</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Negative number signifies &#39;add one dv to each component&#39;</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">compIDs</span><span class="p">:</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">comp</span><span class="p">])</span>
            <span class="n">compIDs</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Otherwise, just put the current list of compIDs in a</span>
            <span class="c1"># list of length 1.</span>
            <span class="n">compIDs</span> <span class="o">=</span> <span class="p">[</span><span class="n">compIDs</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">compIDs</span></div>

<div class="viewcode-block" id="pyTACS.getBDFInfo"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getBDFInfo">[docs]</a>    <span class="k">def</span> <span class="nf">getBDFInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return pynastran bdf object. This object can be used interactively</span>
<span class="sd">        to parse information (nodes, elements, loads etc) included in the bdf file.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bdfInfo : pyNastran.bdf.bdf.BDF</span>
<span class="sd">            pyNastran bdf object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span></div>

<div class="viewcode-block" id="pyTACS.getCompNames"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getCompNames">[docs]</a>    <span class="k">def</span> <span class="nf">getCompNames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compIDs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of component descriptions for the given component</span>
<span class="sd">        IDs. compIDs should come from a call to selectCompIDs</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compIDs : int or list[int] or None</span>
<span class="sd">            List of integers of the compIDs numbers. If None, returns names for all components.</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        compDescript : list</span>
<span class="sd">            List of strings of the names of the corresponding compIDs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Return all component names</span>
        <span class="k">if</span> <span class="n">compIDs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compDescripts</span><span class="p">)</span>
        <span class="c1"># Convert to list</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compIDs</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">compIDs</span> <span class="o">=</span> <span class="p">[</span><span class="n">compIDs</span><span class="p">]</span>
        <span class="c1"># Make sure list is flat</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compIDs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatten</span><span class="p">(</span><span class="n">compIDs</span><span class="p">)</span>

        <span class="n">compDescripts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">compIDs</span><span class="p">)):</span>
            <span class="n">compDescripts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compDescripts</span><span class="p">[</span><span class="n">compIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">compDescripts</span></div>

<div class="viewcode-block" id="pyTACS.initialize"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elemCallBack</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the &#39;last&#39; method to be called during the setup. The</span>
<span class="sd">        user should have already added all the design variables,</span>
<span class="sd">        domains ect. before this function is call. This function</span>
<span class="sd">        finalizes the problem initialization and cannot be changed at</span>
<span class="sd">        later time. If a elemCallBack function is not provided by the user,</span>
<span class="sd">        we will use pyNastran to generate one automatically from element</span>
<span class="sd">        properties provided in the BDF file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elemCallBack : python function handle</span>

<span class="sd">           The calling sequence for elemCallBack **must** be as</span>
<span class="sd">           follows::</span>

<span class="sd">             def elemCallBack(dvNum, compID, compDescript, elemDescripts,</span>
<span class="sd">                             globalDVs, **kwargs):</span>

<span class="sd">           The dvNum is the current counter which must be used by the</span>
<span class="sd">           user when creating constitutive object with design</span>
<span class="sd">           variables.</span>

<span class="sd">           compID is the ID number used by tacs to reference this property group.</span>
<span class="sd">           Use kwargs[&#39;propID&#39;] to get the corresponding Nastran property ID that</span>
<span class="sd">           is read in from the BDF.</span>

<span class="sd">           compDescript is the component description label read in from optional</span>
<span class="sd">           formatted comments in BDF file</span>

<span class="sd">           elemDescripts are the name of the elements belonging to this group</span>
<span class="sd">           (e.g. CQUAD4, CTRIA3, CTETRA, etc). This value will be a list since</span>
<span class="sd">           one component may contain multiple compatible element types.</span>
<span class="sd">           Example: [&#39;CQUAD4&#39;, CTRIA3&#39;]</span>

<span class="sd">           globalDVs is a dictionary containing information about any</span>
<span class="sd">           global DVs that have been added.</span>

<span class="sd">           elemCallBack must return a list containing as many TACS element</span>
<span class="sd">           objects as there are element types in elemDescripts (one for each).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">elemCallBack</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">elemCallBack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elemCallBackFromBDF</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_createOutputGroups</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_createElements</span><span class="p">(</span><span class="n">elemCallBack</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">createTACSAssembler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">varsPerNode</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_createOutputViewer</span><span class="p">()</span>

        <span class="c1"># Store original node locations read in from bdf file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xpts0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createNodeVec</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">getNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xpts0</span><span class="p">)</span>

        <span class="c1"># Store initial design variable values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createDesignVec</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">getDesignVars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_elemCallBackFromBDF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automatically setup elemCallBack using information contained in BDF file.</span>
<span class="sd">        This function assumes all material properties are specified in the BDF.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if any properties are in the BDF</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">missing_properties</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;BDF file &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bdfName</span><span class="si">}</span><span class="s2">&#39; has missing properties cards. &quot;</span>
                <span class="s2">&quot;Set &#39;printDebug&#39; option to True for more information. &quot;</span>
                <span class="s2">&quot;User must define own elemCallBack function.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Make sure cross-referencing is turned on in pynastran</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">is_xrefed</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">cross_reference</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">is_xrefed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Create a dictionary to sort all elements by property number</span>
        <span class="n">elemDict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">elementID</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
            <span class="n">element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">elementID</span><span class="p">]</span>
            <span class="n">propertyID</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">pid</span>
            <span class="k">if</span> <span class="n">propertyID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elemDict</span><span class="p">:</span>
                <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

        <span class="c1"># Create a dictionary to sort all design variables</span>
        <span class="k">for</span> <span class="n">dv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">dvprels</span><span class="p">:</span>
            <span class="n">propertyID</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">dvprels</span><span class="p">[</span><span class="n">dv</span><span class="p">]</span><span class="o">.</span><span class="n">pid</span>
            <span class="n">dvName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">dvprels</span><span class="p">[</span><span class="n">dv</span><span class="p">]</span><span class="o">.</span><span class="n">pname_fid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">dvprels</span><span class="p">[</span><span class="n">dv</span><span class="p">]</span><span class="o">.</span><span class="n">dvids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="n">dvName</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">dvprels</span><span class="p">[</span><span class="n">dv</span><span class="p">]</span>
        <span class="c1"># Create option for user to specify scale values in BDF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaleList</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span>

        <span class="c1"># Callback function to return appropriate tacs MaterialProperties object</span>
        <span class="c1"># For a pynastran mat card</span>
        <span class="k">def</span> <span class="nf">matCallBack</span><span class="p">(</span><span class="n">matInfo</span><span class="p">):</span>
            <span class="c1"># Nastran isotropic material card</span>
            <span class="k">if</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;MAT1&quot;</span><span class="p">:</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">MaterialProperties</span><span class="p">(</span>
                    <span class="n">rho</span><span class="o">=</span><span class="n">matInfo</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span>
                    <span class="n">E</span><span class="o">=</span><span class="n">matInfo</span><span class="o">.</span><span class="n">e</span><span class="p">,</span>
                    <span class="n">nu</span><span class="o">=</span><span class="n">matInfo</span><span class="o">.</span><span class="n">nu</span><span class="p">,</span>
                    <span class="n">ys</span><span class="o">=</span><span class="n">matInfo</span><span class="o">.</span><span class="n">St</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="n">matInfo</span><span class="o">.</span><span class="n">a</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="c1"># Nastran orthotropic material card</span>
            <span class="k">elif</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;MAT8&quot;</span><span class="p">:</span>
                <span class="n">E1</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">e11</span>
                <span class="n">E2</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">e22</span>
                <span class="n">nu12</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">nu12</span>
                <span class="n">G12</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">g12</span>
                <span class="n">G13</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">g1z</span>
                <span class="n">G23</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">g2z</span>
                <span class="c1"># If out-of-plane shear values are 0, Nastran defaults them to the in-plane</span>
                <span class="k">if</span> <span class="n">G13</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">G13</span> <span class="o">=</span> <span class="n">G12</span>
                <span class="k">if</span> <span class="n">G23</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">G23</span> <span class="o">=</span> <span class="n">G12</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">rho</span>
                <span class="n">Xt</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">Xt</span>
                <span class="n">Xc</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">Xc</span>
                <span class="n">Yt</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">Yt</span>
                <span class="n">Yc</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">Yc</span>
                <span class="n">S12</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">S</span>
                <span class="c1"># TODO: add alpha</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">MaterialProperties</span><span class="p">(</span>
                    <span class="n">rho</span><span class="o">=</span><span class="n">rho</span><span class="p">,</span>
                    <span class="n">E1</span><span class="o">=</span><span class="n">E1</span><span class="p">,</span>
                    <span class="n">E2</span><span class="o">=</span><span class="n">E2</span><span class="p">,</span>
                    <span class="n">nu12</span><span class="o">=</span><span class="n">nu12</span><span class="p">,</span>
                    <span class="n">G12</span><span class="o">=</span><span class="n">G12</span><span class="p">,</span>
                    <span class="n">G13</span><span class="o">=</span><span class="n">G13</span><span class="p">,</span>
                    <span class="n">G23</span><span class="o">=</span><span class="n">G23</span><span class="p">,</span>
                    <span class="n">Xt</span><span class="o">=</span><span class="n">Xt</span><span class="p">,</span>
                    <span class="n">Xc</span><span class="o">=</span><span class="n">Xc</span><span class="p">,</span>
                    <span class="n">Yt</span><span class="o">=</span><span class="n">Yt</span><span class="p">,</span>
                    <span class="n">Yc</span><span class="o">=</span><span class="n">Yc</span><span class="p">,</span>
                    <span class="n">S12</span><span class="o">=</span><span class="n">S12</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="c1"># Nastran 2D anisotropic material card</span>
            <span class="k">elif</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;MAT2&quot;</span><span class="p">:</span>
                <span class="n">C11</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">G11</span>
                <span class="n">C12</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">G12</span>
                <span class="n">C22</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">G22</span>
                <span class="n">C13</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">G13</span>
                <span class="n">C23</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">G23</span>
                <span class="n">C33</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">G33</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">rho</span>
                <span class="c1"># See if this card features anisotropic coupling terms (which we don&#39;t support yet)</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">C13</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">C11</span> <span class="o">+</span> <span class="n">C22</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">1e-8</span>
                    <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">C23</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">C11</span> <span class="o">+</span> <span class="n">C22</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">1e-8</span>
                <span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_TACSWarning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;MAT2 card </span><span class="si">{</span><span class="n">matInfo</span><span class="o">.</span><span class="n">mid</span><span class="si">}</span><span class="s2"> has anisotropic stiffness components that are not currently supported. &quot;</span>
                        <span class="s2">&quot;These terms will be dropped and the material treated as orthotropic. &quot;</span>
                        <span class="s2">&quot;Result accuracy may be affected.&quot;</span>
                    <span class="p">)</span>
                <span class="n">nu12</span> <span class="o">=</span> <span class="n">C12</span> <span class="o">/</span> <span class="n">C22</span>
                <span class="n">nu21</span> <span class="o">=</span> <span class="n">C12</span> <span class="o">/</span> <span class="n">C11</span>
                <span class="n">E1</span> <span class="o">=</span> <span class="n">C11</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">nu12</span> <span class="o">*</span> <span class="n">nu21</span><span class="p">)</span>
                <span class="n">E2</span> <span class="o">=</span> <span class="n">C22</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">nu12</span> <span class="o">*</span> <span class="n">nu21</span><span class="p">)</span>
                <span class="n">G12</span> <span class="o">=</span> <span class="n">G13</span> <span class="o">=</span> <span class="n">G23</span> <span class="o">=</span> <span class="n">C33</span>
                <span class="c1"># TODO: add alpha</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">MaterialProperties</span><span class="p">(</span>
                    <span class="n">rho</span><span class="o">=</span><span class="n">rho</span><span class="p">,</span> <span class="n">E1</span><span class="o">=</span><span class="n">E1</span><span class="p">,</span> <span class="n">E2</span><span class="o">=</span><span class="n">E2</span><span class="p">,</span> <span class="n">nu12</span><span class="o">=</span><span class="n">nu12</span><span class="p">,</span> <span class="n">G12</span><span class="o">=</span><span class="n">G12</span><span class="p">,</span> <span class="n">G13</span><span class="o">=</span><span class="n">G13</span><span class="p">,</span> <span class="n">G23</span><span class="o">=</span><span class="n">G23</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unsupported material type &#39;</span><span class="si">{</span><span class="n">matInfo</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&#39; for material number </span><span class="si">{</span><span class="n">matInfo</span><span class="o">.</span><span class="n">mid</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="n">mat</span>

        <span class="k">def</span> <span class="nf">elemCallBack</span><span class="p">(</span>
            <span class="n">dvNum</span><span class="p">,</span> <span class="n">compID</span><span class="p">,</span> <span class="n">compDescript</span><span class="p">,</span> <span class="n">elemDescripts</span><span class="p">,</span> <span class="n">globalDVs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">):</span>
            <span class="c1"># Initialize scale list for design variables we will add</span>
            <span class="n">scaleList</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Get the Nastran property ID</span>
            <span class="n">propertyID</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;propID&quot;</span><span class="p">]</span>
            <span class="n">propInfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">propertyID</span><span class="p">]</span>
            <span class="n">elemInfo</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># First we define the material object</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># This property only references one material</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">propInfo</span><span class="p">,</span> <span class="s2">&quot;mid_ref&quot;</span><span class="p">):</span>
                <span class="n">matInfo</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">mid_ref</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">matCallBack</span><span class="p">(</span><span class="n">matInfo</span><span class="p">)</span>
            <span class="c1"># This property references multiple materials (maybe a laminate)</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">propInfo</span><span class="p">,</span> <span class="s2">&quot;mids_ref&quot;</span><span class="p">):</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">matInfo</span> <span class="ow">in</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">mids_ref</span><span class="p">:</span>
                    <span class="n">mat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matCallBack</span><span class="p">(</span><span class="n">matInfo</span><span class="p">))</span>

            <span class="c1"># Next we define the constitutive object</span>
            <span class="k">if</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;PSHELL&quot;</span><span class="p">:</span>  <span class="c1"># Nastran isotropic shell</span>
                <span class="n">kcorr</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">tst</span>

                <span class="k">if</span> <span class="s2">&quot;T&quot;</span> <span class="ow">in</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">]:</span>
                    <span class="n">thickness</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xinit</span>
                    <span class="n">tNum</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">minThickness</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xlb</span>
                    <span class="n">maxThickness</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xub</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">scaleList</span><span class="p">[</span><span class="n">tNum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span>
                        <span class="mi">0</span>
                    <span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">thickness</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">t</span>
                    <span class="n">tNum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">minThickness</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="n">maxThickness</span> <span class="o">=</span> <span class="mf">1e20</span>

                <span class="n">con</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">IsoShellConstitutive</span><span class="p">(</span>
                    <span class="n">mat</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">thickness</span><span class="p">,</span> <span class="n">tlb</span><span class="o">=</span><span class="n">minThickness</span><span class="p">,</span> <span class="n">tub</span><span class="o">=</span><span class="n">maxThickness</span><span class="p">,</span> <span class="n">tNum</span><span class="o">=</span><span class="n">tNum</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;PCOMP&quot;</span><span class="p">:</span>  <span class="c1"># Nastran composite shell</span>
                <span class="n">numPlies</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">nplies</span>
                <span class="n">plyThicknesses</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">plyAngles</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">plyMats</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># if the laminate is symmetric, mirror the ply indices</span>
                <span class="k">if</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">lam</span> <span class="o">==</span> <span class="s2">&quot;SYM&quot;</span><span class="p">:</span>
                    <span class="n">plyIndices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">numPlies</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
                    <span class="n">plyIndices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">plyIndices</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">plyIndices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">numPlies</span><span class="p">)</span>

                <span class="c1"># Loop through plies and setup each entry in layup</span>
                <span class="k">for</span> <span class="n">ply_i</span> <span class="ow">in</span> <span class="n">plyIndices</span><span class="p">:</span>
                    <span class="n">plyThicknesses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">propInfo</span><span class="o">.</span><span class="n">thicknesses</span><span class="p">[</span><span class="n">ply_i</span><span class="p">])</span>
                    <span class="n">plyMat</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">OrthotropicPly</span><span class="p">(</span>
                        <span class="n">plyThicknesses</span><span class="p">[</span><span class="n">ply_i</span><span class="p">],</span> <span class="n">mat</span><span class="p">[</span><span class="n">ply_i</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">plyMats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plyMat</span><span class="p">)</span>
                    <span class="n">plyAngles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">propInfo</span><span class="o">.</span><span class="n">thetas</span><span class="p">[</span><span class="n">ply_i</span><span class="p">]))</span>

                <span class="c1"># Convert thickness/angles to appropriate numpy array</span>
                <span class="n">plyThicknesses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">plyThicknesses</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">plyAngles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">plyAngles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">lam</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">lam</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;SYM&quot;</span><span class="p">,</span> <span class="s2">&quot;MEM&quot;</span><span class="p">]:</span>
                    <span class="c1"># Discrete laminate class (not for optimization)</span>
                    <span class="n">con</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">CompositeShellConstitutive</span><span class="p">(</span>
                        <span class="n">plyMats</span><span class="p">,</span> <span class="n">plyThicknesses</span><span class="p">,</span> <span class="n">plyAngles</span>
                    <span class="p">)</span>
                    <span class="c1"># Need to add functionality to consider only membrane in TACS for type = MEM</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Unrecognized LAM type &#39;</span><span class="si">{</span><span class="n">propInfo</span><span class="o">.</span><span class="n">lam</span><span class="si">}</span><span class="s2">&#39; for PCOMP number </span><span class="si">{</span><span class="n">propertyID</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>

            <span class="k">elif</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;PSOLID&quot;</span><span class="p">:</span>  <span class="c1"># Nastran solid property</span>
                <span class="k">if</span> <span class="s2">&quot;T&quot;</span> <span class="ow">in</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">]:</span>
                    <span class="n">thickness</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xinit</span>
                    <span class="n">tNum</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">minThickness</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xlb</span>
                    <span class="n">maxThickness</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xub</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">scaleList</span><span class="p">[</span><span class="n">tNum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span>
                        <span class="mi">0</span>
                    <span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">thickness</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="n">tNum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">minThickness</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="n">maxThickness</span> <span class="o">=</span> <span class="mf">10.0</span>

                <span class="n">con</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">SolidConstitutive</span><span class="p">(</span>
                    <span class="n">mat</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">thickness</span><span class="p">,</span> <span class="n">tlb</span><span class="o">=</span><span class="n">minThickness</span><span class="p">,</span> <span class="n">tub</span><span class="o">=</span><span class="n">maxThickness</span><span class="p">,</span> <span class="n">tNum</span><span class="o">=</span><span class="n">tNum</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;PBUSH&quot;</span><span class="p">:</span>  <span class="c1"># Nastran spring</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">Ki</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="n">k</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">Ki</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">con</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">DOFSpringConstitutive</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;PBAR&quot;</span><span class="p">:</span>  <span class="c1"># Nastran bar</span>
                <span class="n">area</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">A</span>
                <span class="n">I1</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">i1</span>
                <span class="n">I2</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">i2</span>
                <span class="n">I12</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">i12</span>
                <span class="n">J</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">j</span>
                <span class="n">k1</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">k1</span>
                <span class="n">k2</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">k2</span>

                <span class="k">if</span> <span class="n">k1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">k1</span> <span class="o">=</span> <span class="mf">1e6</span>
                <span class="k">if</span> <span class="n">k2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">k2</span> <span class="o">=</span> <span class="mf">1e6</span>

                <span class="n">con</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">BasicBeamConstitutive</span><span class="p">(</span>
                    <span class="n">mat</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">area</span><span class="p">,</span> <span class="n">Iy</span><span class="o">=</span><span class="n">I2</span><span class="p">,</span> <span class="n">Iz</span><span class="o">=</span><span class="n">I1</span><span class="p">,</span> <span class="n">Iyz</span><span class="o">=</span><span class="n">I12</span><span class="p">,</span> <span class="n">J</span><span class="o">=</span><span class="n">J</span><span class="p">,</span> <span class="n">ky</span><span class="o">=</span><span class="n">k1</span><span class="p">,</span> <span class="n">kz</span><span class="o">=</span><span class="n">k2</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;PROD&quot;</span><span class="p">:</span>  <span class="c1"># Nastran rod</span>
                <span class="n">area</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">A</span>
                <span class="n">J</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">j</span>
                <span class="n">k1</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">k2</span> <span class="o">=</span> <span class="mf">0.0</span>

                <span class="n">con</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">BasicBeamConstitutive</span><span class="p">(</span>
                    <span class="n">mat</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">area</span><span class="p">,</span> <span class="n">J</span><span class="o">=</span><span class="n">J</span><span class="p">,</span> <span class="n">ky</span><span class="o">=</span><span class="n">k1</span><span class="p">,</span> <span class="n">kz</span><span class="o">=</span><span class="n">k2</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unsupported property type &#39;</span><span class="si">{</span><span class="n">propInfo</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&#39; for property number </span><span class="si">{</span><span class="n">propertyID</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="p">)</span>

            <span class="c1"># Set up transform object which may be required for certain elements</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;PSHELL&quot;</span><span class="p">,</span> <span class="s2">&quot;PCOMP&quot;</span><span class="p">]:</span>
                <span class="n">mcid</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">theta_mcid_ref</span>
                <span class="k">if</span> <span class="n">mcid</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">mcid</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;CORD2R&quot;</span><span class="p">:</span>
                        <span class="n">refAxis</span> <span class="o">=</span> <span class="n">mcid</span><span class="o">.</span><span class="n">i</span>
                        <span class="n">transform</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">ShellRefAxisTransform</span><span class="p">(</span><span class="n">refAxis</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Don&#39;t support spherical/cylindrical yet</span>
                        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                            <span class="s2">&quot;Unsupported material coordinate system type &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">mcid</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&#39; for property number </span><span class="si">{</span><span class="n">propertyID</span><span class="si">}</span><span class="s2">.&quot;</span>
                        <span class="p">)</span>
            <span class="k">elif</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;PBAR&quot;</span><span class="p">]:</span>
                <span class="n">refAxis</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">g0_vector</span>
                <span class="n">transform</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">BeamRefAxisTransform</span><span class="p">(</span><span class="n">refAxis</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;PROD&quot;</span><span class="p">:</span>
                <span class="n">refAxis</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
                <span class="p">)</span>  <span class="c1"># dummy ref_axis, not really needed for rods</span>
                <span class="n">transform</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">BeamRefAxisTransform</span><span class="p">(</span><span class="n">refAxis</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;PBUSH&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cid_ref</span><span class="p">:</span>
                    <span class="n">refAxis_i</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cid_ref</span><span class="o">.</span><span class="n">i</span>
                    <span class="n">refAxis_j</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cid_ref</span><span class="o">.</span><span class="n">j</span>
                    <span class="n">transform</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">SpringRefFrameTransform</span><span class="p">(</span>
                        <span class="n">refAxis_i</span><span class="p">,</span> <span class="n">refAxis_j</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">refAxis</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                        <span class="o">-</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="o">.</span><span class="n">nodes_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="o">.</span><span class="n">get_position</span><span class="p">()</span>
                    <span class="p">)</span>
                    <span class="n">transform</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">SpringRefAxisTransform</span><span class="p">(</span><span class="n">refAxis</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">g0_ref</span><span class="p">:</span>
                    <span class="n">refAxis</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">g0_ref</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span>
                        <span class="o">-</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="o">.</span><span class="n">nodes_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="o">.</span><span class="n">get_position</span><span class="p">()</span>
                    <span class="p">)</span>
                    <span class="n">transform</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">SpringRefAxisTransform</span><span class="p">(</span><span class="n">refAxis</span><span class="p">)</span>

            <span class="c1"># Finally set up the element objects belonging to this component</span>
            <span class="n">elemList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">descript</span> <span class="ow">in</span> <span class="n">elemDescripts</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">descript</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CQUAD4&quot;</span><span class="p">,</span> <span class="s2">&quot;CQUADR&quot;</span><span class="p">]:</span>
                    <span class="n">elem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">Quad4Shell</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">con</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">descript</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CQUAD9&quot;</span><span class="p">,</span> <span class="s2">&quot;CQUAD&quot;</span><span class="p">]:</span>
                    <span class="n">elem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">Quad9Shell</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">con</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">descript</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CTRIA3&quot;</span><span class="p">,</span> <span class="s2">&quot;CTRIAR&quot;</span><span class="p">]:</span>
                    <span class="n">elem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">Tri3Shell</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">con</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">descript</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CBAR&quot;</span><span class="p">,</span> <span class="s2">&quot;CROD&quot;</span><span class="p">]:</span>
                    <span class="n">elem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">Beam2</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">con</span><span class="p">)</span>
                <span class="k">elif</span> <span class="s2">&quot;CTETRA&quot;</span> <span class="ow">in</span> <span class="n">descript</span><span class="p">:</span>
                    <span class="c1"># May have variable number of nodes in card</span>
                    <span class="n">nnodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">elemInfo</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">nnodes</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                        <span class="n">basis</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">LinearTetrahedralBasis</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="n">nnodes</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                        <span class="n">basis</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">QuadraticTetrahedralBasis</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;TACS does not currently support CTETRA elements with </span><span class="si">{</span><span class="n">nnodes</span><span class="si">}</span><span class="s2"> nodes.&quot;</span>
                        <span class="p">)</span>
                    <span class="n">model</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">LinearElasticity3D</span><span class="p">(</span><span class="n">con</span><span class="p">)</span>
                    <span class="n">elem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">Element3D</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">basis</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">descript</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CHEXA8&quot;</span><span class="p">,</span> <span class="s2">&quot;CHEXA&quot;</span><span class="p">]:</span>
                    <span class="n">basis</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">LinearHexaBasis</span><span class="p">()</span>
                    <span class="n">model</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">LinearElasticity3D</span><span class="p">(</span><span class="n">con</span><span class="p">)</span>
                    <span class="n">elem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">Element3D</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">basis</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">descript</span> <span class="o">==</span> <span class="s2">&quot;CBUSH&quot;</span><span class="p">:</span>
                    <span class="n">elem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">SpringElement</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">con</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                        <span class="s2">&quot;Unsupported element type &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">descript</span><span class="si">}</span><span class="s2">&#39; specified for property number </span><span class="si">{</span><span class="n">propertyID</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
                <span class="n">elemList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">elemList</span><span class="p">,</span> <span class="n">scaleList</span>

        <span class="k">return</span> <span class="n">elemCallBack</span>

<div class="viewcode-block" id="pyTACS.getOrigDesignVars"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getOrigDesignVars">[docs]</a>    <span class="k">def</span> <span class="nf">getOrigDesignVars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get the original design variables that were specified with</span>
<span class="sd">        during assembler creation.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array</span>
<span class="sd">            The current design variable vector set in tacs.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initializeError</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="pyTACS.createDesignVec"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.createDesignVec">[docs]</a>    <span class="k">def</span> <span class="nf">createDesignVec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">asBVec</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new tacs distributed design vector.</span>
<span class="sd">        Values are initialized to zero.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        asBVec : bool</span>
<span class="sd">            Flag that determines whether to return</span>
<span class="sd">            design vector as tacs :class:`~TACS.Vec` (True) or numpy array (False).</span>
<span class="sd">            Defaults to False.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        x : numpy.ndarray or TACS.Vec</span>
<span class="sd">            Distributed design variable vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initializeError</span><span class="p">()</span>

        <span class="n">xVec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createDesignVec</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">asBVec</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xVec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xVec</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span></div>

<div class="viewcode-block" id="pyTACS.getNumDesignVars"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getNumDesignVars">[docs]</a>    <span class="k">def</span> <span class="nf">getNumDesignVars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of design variables on this processor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initializeError</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="o">.</span><span class="n">getSize</span><span class="p">()</span></div>

<div class="viewcode-block" id="pyTACS.getTotalNumDesignVars"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getTotalNumDesignVars">[docs]</a>    <span class="k">def</span> <span class="nf">getTotalNumDesignVars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of design variables across all processors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initializeError</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span></div>

<div class="viewcode-block" id="pyTACS.getOrigNodes"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getOrigNodes">[docs]</a>    <span class="k">def</span> <span class="nf">getOrigNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the original mesh coordiantes read in from the meshLoader.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coords : array</span>
<span class="sd">            Structural coordinate in array of size (N * 3) where N is</span>
<span class="sd">            the number of structural nodes on this processor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initializeError</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xpts0</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="pyTACS.createNodeVec"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.createNodeVec">[docs]</a>    <span class="k">def</span> <span class="nf">createNodeVec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">asBVec</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new tacs distributed node vector.</span>
<span class="sd">        Values are initialized to zero.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        asBVec : bool</span>
<span class="sd">            Flag that determines whether to return</span>
<span class="sd">            node vector as tacs :class:`~TACS.Vec` (True) or numpy array (False).</span>
<span class="sd">            Defaults to False.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        xpts : numpy.ndarray or TACS.Vec</span>
<span class="sd">            Distributed node coordinate vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initializeError</span><span class="p">()</span>

        <span class="n">xptVec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createNodeVec</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">asBVec</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xptVec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xptVec</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span></div>

<div class="viewcode-block" id="pyTACS.getNumOwnedNodes"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getNumOwnedNodes">[docs]</a>    <span class="k">def</span> <span class="nf">getNumOwnedNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of nodes owned by this processor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initializeError</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">getNumOwnedNodes</span><span class="p">()</span></div>

<div class="viewcode-block" id="pyTACS.getNumOwnedMultiplierNodes"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getNumOwnedMultiplierNodes">[docs]</a>    <span class="k">def</span> <span class="nf">getNumOwnedMultiplierNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get number of multiplier nodes owned by this processor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initializeError</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getLocalMultiplierNodeIDs</span><span class="p">())</span></div>

<div class="viewcode-block" id="pyTACS.getLocalMultiplierNodeIDs"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getLocalMultiplierNodeIDs">[docs]</a>    <span class="k">def</span> <span class="nf">getLocalMultiplierNodeIDs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the tacs indices of multiplier nodes used to hold lagrange multipliers on this processor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initializeError</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getLocalMultiplierNodeIDs</span><span class="p">()</span></div>

<div class="viewcode-block" id="pyTACS.createVec"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.createVec">[docs]</a>    <span class="k">def</span> <span class="nf">createVec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">asBVec</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new tacs distributed state variable vector.</span>
<span class="sd">        Values are initialized to zero.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        asBVec : bool</span>
<span class="sd">            Flag that determines whether to return</span>
<span class="sd">            state vector as tacs :class:`~TACS.Vec` (True) or numpy array (False).</span>
<span class="sd">            Defaults to False.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        vars : numpy.ndarray or TACS.Vec</span>
<span class="sd">            Distributed state variable vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initializeError</span><span class="p">()</span>

        <span class="nb">vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createVec</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">asBVec</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">vars</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">vars</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span></div>

<div class="viewcode-block" id="pyTACS.getVarsPerNode"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getVarsPerNode">[docs]</a>    <span class="k">def</span> <span class="nf">getVarsPerNode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of variables per node for the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initializeError</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">getVarsPerNode</span><span class="p">()</span></div>

<div class="viewcode-block" id="pyTACS.applyBCsToVec"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.applyBCsToVec">[docs]</a>    <span class="k">def</span> <span class="nf">applyBCsToVec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies zeros to boundary condition dofs in input vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initializeError</span><span class="p">()</span>

        <span class="n">varVec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createVec</span><span class="p">()</span>
        <span class="n">varArray</span> <span class="o">=</span> <span class="n">varVec</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span>

        <span class="c1"># Check if input is a BVec or numpy array</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">Vec</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">applyBCs</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">vec</span>
            <span class="c1"># Create temporary BVec</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createVec</span><span class="p">()</span>
            <span class="c1"># Copy array values to BVec</span>
            <span class="n">vec</span><span class="o">.</span><span class="n">getArray</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">array</span>
            <span class="c1"># Apply BCs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">applyBCs</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
            <span class="c1"># Copy values back to array</span>
            <span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span></div>

<div class="viewcode-block" id="pyTACS.createStaticProblem"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.createStaticProblem">[docs]</a>    <span class="k">def</span> <span class="nf">createStaticProblem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new staticProblem for modeling a static load cases.</span>
<span class="sd">        This object can be used to set loads, evalFunctions as well as perform</span>
<span class="sd">        solutions and sensitivities related to static problems</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name to assign problem.</span>
<span class="sd">        options : dict</span>
<span class="sd">            Problem-specific options to pass to StaticProblem instance (case-insensitive).</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        problem : StaticProblem</span>
<span class="sd">            StaticProblem object used for modeling and solving static cases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initializeError</span><span class="p">()</span>

        <span class="n">problem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">problems</span><span class="o">.</span><span class="n">static</span><span class="o">.</span><span class="n">StaticProblem</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputViewer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="p">,</span> <span class="n">options</span>
        <span class="p">)</span>
        <span class="c1"># Set with original design vars and coordinates, in case they have changed</span>
        <span class="n">problem</span><span class="o">.</span><span class="n">setDesignVars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">problem</span><span class="o">.</span><span class="n">setNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xpts0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">problem</span></div>

<div class="viewcode-block" id="pyTACS.createTransientProblem"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.createTransientProblem">[docs]</a>    <span class="k">def</span> <span class="nf">createTransientProblem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">tInit</span><span class="p">,</span> <span class="n">tFinal</span><span class="p">,</span> <span class="n">numSteps</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new TransientProblem for modeling a transient load cases.</span>
<span class="sd">        This object can be used to set loads, evalFunctions as well as perform</span>
<span class="sd">        solutions and sensitivities related to transient problems</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name to assign problem.</span>
<span class="sd">        tInit : float</span>
<span class="sd">            Starting time for transient time integration</span>
<span class="sd">        tFinal : float</span>
<span class="sd">            Ending time for transient time integration</span>
<span class="sd">        numSteps : int</span>
<span class="sd">            Number of time steps for transient time integration</span>
<span class="sd">        options : dict</span>
<span class="sd">            Problem-specific options to pass to TransientProblem instance (case-insensitive).</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        problem : TransientProblem</span>
<span class="sd">            TransientProblem object used for modeling and solving transient cases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initializeError</span><span class="p">()</span>

        <span class="n">problem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">problems</span><span class="o">.</span><span class="n">transient</span><span class="o">.</span><span class="n">TransientProblem</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">tInit</span><span class="p">,</span>
            <span class="n">tFinal</span><span class="p">,</span>
            <span class="n">numSteps</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputViewer</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="p">,</span>
            <span class="n">options</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Set with original design vars and coordinates, in case they have changed</span>
        <span class="n">problem</span><span class="o">.</span><span class="n">setDesignVars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">problem</span><span class="o">.</span><span class="n">setNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xpts0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">problem</span></div>

<div class="viewcode-block" id="pyTACS.createModalProblem"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.createModalProblem">[docs]</a>    <span class="k">def</span> <span class="nf">createModalProblem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">numEigs</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new ModalProblem for performing modal analysis.</span>
<span class="sd">        This problem can be used to identify the natural frequencies and mode</span>
<span class="sd">        shapes of the model through eigenvalue analysis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name to assign problem.</span>
<span class="sd">        sigma : float</span>
<span class="sd">            Guess for the lowest eigenvalue.</span>
<span class="sd">            This corresponds to the lowest expected frequency squared. (rad^2/s^2)</span>
<span class="sd">        numEigs : int</span>
<span class="sd">            Number of eigenvalues to solve for.</span>
<span class="sd">        options : dict</span>
<span class="sd">            Problem-specific options to pass to ModalProblem instance (case-insensitive).</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        problem : ModalProblem</span>
<span class="sd">            ModalProblem object used for performing modal eigenvalue analysis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initializeError</span><span class="p">()</span>

        <span class="n">problem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">problems</span><span class="o">.</span><span class="n">modal</span><span class="o">.</span><span class="n">ModalProblem</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">sigma</span><span class="p">,</span>
            <span class="n">numEigs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputViewer</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="p">,</span>
            <span class="n">options</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Set with original design vars and coordinates, in case they have changed</span>
        <span class="n">problem</span><span class="o">.</span><span class="n">setDesignVars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">problem</span><span class="o">.</span><span class="n">setNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xpts0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">problem</span></div>

<div class="viewcode-block" id="pyTACS.createTACSProbsFromBDF"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.createTACSProbsFromBDF">[docs]</a>    <span class="k">def</span> <span class="nf">createTACSProbsFromBDF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automatically define tacs problem classes with loads using information contained in BDF file.</span>
<span class="sd">        This function assumes all loads are specified in the BDF and allows users to</span>
<span class="sd">        skip setting loads in Python.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        structProblems : dict[TACSProblem]</span>
<span class="sd">            Dictionary containing a predfined TACSProblem for every loadcase found int the BDF.</span>
<span class="sd">            The dictionary keys are the loadcase IDs from the BDF.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Currently only supports LOAD, FORCE, MOMENT, GRAV, RFORCE, PLOAD2, PLOAD4, TLOAD1, TLOAD2, and DLOAD cards.</span>
<span class="sd">        Currently only supports staticProblem (SOL 101), transientProblem (SOL 109), and modalProblems (SOL 103)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initializeError</span><span class="p">()</span>

        <span class="c1"># Make sure cross-referencing is turned on in pynastran</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">is_xrefed</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">cross_reference</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">is_xrefed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">structProblems</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># If subcases have been added in Nastran, then subCase 0 should not be run</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">subcases</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">skipCaseZero</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">skipCaseZero</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Loop through every load set and create a corresponding structural problem</span>
        <span class="k">for</span> <span class="n">subCase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">subcases</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">skipCaseZero</span> <span class="ow">and</span> <span class="n">subCase</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="s2">&quot;SUBTITLE&quot;</span> <span class="ow">in</span> <span class="n">subCase</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">subCase</span><span class="p">[</span><span class="s2">&quot;SUBTITLE&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;load_set_</span><span class="si">%.3d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">subCase</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">sol</span> <span class="o">==</span> <span class="mi">103</span><span class="p">:</span>
                <span class="n">methodID</span> <span class="o">=</span> <span class="n">subCase</span><span class="p">[</span><span class="s2">&quot;METHOD&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">methodInfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">methods</span><span class="p">[</span><span class="n">methodID</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">methodInfo</span><span class="o">.</span><span class="n">v1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sigma</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">methodInfo</span><span class="o">.</span><span class="n">v1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="k">elif</span> <span class="n">methodInfo</span><span class="o">.</span><span class="n">v2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sigma</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">methodInfo</span><span class="o">.</span><span class="n">v2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sigma</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="k">if</span> <span class="n">methodInfo</span><span class="o">.</span><span class="n">nd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">nEigs</span> <span class="o">=</span> <span class="n">methodInfo</span><span class="o">.</span><span class="n">nd</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nEigs</span> <span class="o">=</span> <span class="mi">20</span>
                <span class="n">problem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createModalProblem</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">nEigs</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">sol</span> <span class="o">==</span> <span class="mi">109</span><span class="p">:</span>
                <span class="c1"># Get time step info</span>
                <span class="k">if</span> <span class="s2">&quot;TSTEP&quot;</span> <span class="ow">in</span> <span class="n">subCase</span><span class="p">:</span>
                    <span class="n">tStepID</span> <span class="o">=</span> <span class="n">subCase</span><span class="p">[</span><span class="s2">&quot;TSTEP&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">tStep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">tsteps</span><span class="p">[</span><span class="n">tStepID</span><span class="p">]</span>
                    <span class="n">nSteps</span> <span class="o">=</span> <span class="n">tStep</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">dt</span> <span class="o">=</span> <span class="n">tStep</span><span class="o">.</span><span class="n">DT</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># If no time step info was included, we&#39;ll skip this case</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_TACSWarning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;No TSTEP entry found in control deck for subcase number </span><span class="si">{</span><span class="n">subCase</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="s2">&quot;skipping case.&quot;</span>
                    <span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">problem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createTransientProblem</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">tInit</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">tFinal</span><span class="o">=</span><span class="n">dt</span> <span class="o">*</span> <span class="n">nSteps</span><span class="p">,</span> <span class="n">numSteps</span><span class="o">=</span><span class="n">nSteps</span>
                <span class="p">)</span>

                <span class="c1"># Find dynamic load specified for this subcase</span>
                <span class="k">if</span> <span class="s2">&quot;DLOAD&quot;</span> <span class="ow">in</span> <span class="n">subCase</span><span class="p">:</span>
                    <span class="n">dloadsID</span> <span class="o">=</span> <span class="n">subCase</span><span class="p">[</span><span class="s2">&quot;DLOAD&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">dloadSet</span><span class="p">,</span> <span class="n">dloadScale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">get_reduced_dloads</span><span class="p">(</span><span class="n">dloadsID</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">dloadInfo</span><span class="p">,</span> <span class="n">dscale</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dloadSet</span><span class="p">,</span> <span class="n">dloadScale</span><span class="p">):</span>
                        <span class="n">timeSteps</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">getTimeSteps</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">dloadInfo</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;TLOAD1&quot;</span><span class="p">,</span> <span class="s2">&quot;TLOAD2&quot;</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">dloadInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;TLOAD1&quot;</span><span class="p">:</span>
                                <span class="n">loadScales</span> <span class="o">=</span> <span class="n">dloadInfo</span><span class="o">.</span><span class="n">get_load_at_time</span><span class="p">(</span>
                                    <span class="n">timeSteps</span><span class="p">,</span> <span class="n">dscale</span>
                                <span class="p">)</span>
                            <span class="k">elif</span> <span class="n">dloadInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;TLOAD2&quot;</span><span class="p">:</span>
                                <span class="n">loadScales</span> <span class="o">=</span> <span class="n">_tload2_get_load_at_time</span><span class="p">(</span>
                                    <span class="n">dloadInfo</span><span class="p">,</span> <span class="n">timeSteps</span><span class="p">,</span> <span class="n">dscale</span>
                                <span class="p">)</span>
                            <span class="k">if</span> <span class="n">dloadInfo</span><span class="o">.</span><span class="n">Type</span> <span class="o">!=</span> <span class="s2">&quot;LOAD&quot;</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_TACSWarning</span><span class="p">(</span>
                                    <span class="s2">&quot;Only &#39;LOAD&#39; types are supported for &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">dloadInfo</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&#39; card, but &#39;</span><span class="si">{</span><span class="n">dloadInfo</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&#39; </span><span class="si">{</span><span class="n">dloadInfo</span><span class="o">.</span><span class="n">sid</span><span class="si">}</span><span class="s2">, &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;was specified as </span><span class="si">{</span><span class="n">dloadInfo</span><span class="o">.</span><span class="n">Type</span><span class="si">}</span><span class="s2"> type&quot;</span>
                                <span class="p">)</span>
                            <span class="n">loadsID</span> <span class="o">=</span> <span class="n">dloadInfo</span><span class="o">.</span><span class="n">excite_id</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_TACSWarning</span><span class="p">(</span>
                                <span class="s2">&quot;Unsupported dload type &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">dloadInfo</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&#39; specified for load set number </span><span class="si">{</span><span class="n">dloadInfo</span><span class="o">.</span><span class="n">sid</span><span class="si">}</span><span class="s2">,&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot; skipping load&quot;</span>
                            <span class="p">)</span>
                            <span class="k">continue</span>
                        <span class="c1"># Loop through each time step and add loads to problem</span>
                        <span class="k">for</span> <span class="n">timeIndex</span><span class="p">,</span> <span class="n">scale</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">loadScales</span><span class="p">):</span>
                            <span class="n">problem</span><span class="o">.</span><span class="n">addLoadFromBDF</span><span class="p">(</span><span class="n">timeIndex</span><span class="p">,</span> <span class="n">loadsID</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">problem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createStaticProblem</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

                <span class="c1"># Find the static load specified for this test case</span>
                <span class="k">if</span> <span class="s2">&quot;LOAD&quot;</span> <span class="ow">in</span> <span class="n">subCase</span><span class="p">:</span>
                    <span class="c1"># Add loads to problem</span>
                    <span class="n">loadsID</span> <span class="o">=</span> <span class="n">subCase</span><span class="p">[</span><span class="s2">&quot;LOAD&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">problem</span><span class="o">.</span><span class="n">addLoadFromBDF</span><span class="p">(</span><span class="n">loadsID</span><span class="p">)</span>

            <span class="c1"># append to list of structural problems</span>
            <span class="n">structProblems</span><span class="p">[</span><span class="n">subCase</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">problem</span>

        <span class="k">return</span> <span class="n">structProblems</span></div>

<div class="viewcode-block" id="pyTACS.getNumComponents"><a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getNumComponents">[docs]</a>    <span class="k">def</span> <span class="nf">getNumComponents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return number of components (property) groups found in bdf.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nComp</span></div>

    <span class="k">def</span> <span class="nf">_createOutputGroups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Automatically determine how to split out the output file</span>
<span class="sd">        for easier viewing&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fam</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="p">):</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compDescripts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;familySeparator&quot;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fam</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Uniqify them and sort</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fam</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fam</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compFam</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;intc&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="p">):</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compDescripts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;familySeparator&quot;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compFam</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fam</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_createOutputViewer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method to create the appropriate output viewer</span>
<span class="sd">        (TACSToFH5 object) for TACS.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Depending on the user supplied options generate the</span>
        <span class="c1"># write_flag</span>
        <span class="n">write_flag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;writeConnectivity&quot;</span><span class="p">):</span>
            <span class="n">write_flag</span> <span class="o">|=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">OUTPUT_CONNECTIVITY</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;writeNodes&quot;</span><span class="p">):</span>
            <span class="n">write_flag</span> <span class="o">|=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">OUTPUT_NODES</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;writeDisplacements&quot;</span><span class="p">):</span>
            <span class="n">write_flag</span> <span class="o">|=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">OUTPUT_DISPLACEMENTS</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;writeStrains&quot;</span><span class="p">):</span>
            <span class="n">write_flag</span> <span class="o">|=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">OUTPUT_STRAINS</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;writeStresses&quot;</span><span class="p">):</span>
            <span class="n">write_flag</span> <span class="o">|=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">OUTPUT_STRESSES</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;writeExtras&quot;</span><span class="p">):</span>
            <span class="n">write_flag</span> <span class="o">|=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">OUTPUT_EXTRAS</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;writeCoordinateFrame&quot;</span><span class="p">):</span>
            <span class="n">write_flag</span> <span class="o">|=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">OUTPUT_COORDINATES</span>

        <span class="c1"># Create actual viewer</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;outputElement&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">elementType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;outputElement&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Set the output type based on the first element in the model</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getElementObjectForElemID</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nastranOrdering</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">elementType</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">getElementType</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">outputViewer</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">ToFH5</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="p">,</span> <span class="n">elementType</span><span class="p">,</span> <span class="n">write_flag</span><span class="p">)</span>

        <span class="c1"># Set the names of each of the output families</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fam</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputViewer</span><span class="o">.</span><span class="n">setComponentName</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fam</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_getCompIDs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">inList</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal method to return the component IDs mathing</span>
<span class="sd">        information in inList&quot;&quot;&quot;</span>

        <span class="c1"># First recursively flatten the inList in case it was nested:</span>
        <span class="n">inList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatten</span><span class="p">(</span><span class="n">inList</span><span class="p">)</span>

        <span class="c1"># Neste list container for compIDs</span>
        <span class="n">compIDs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Look at each item in list (which is a list because of the *)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">inList</span><span class="p">:</span>
            <span class="n">compIDs</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="c1"># Integers are easy, just check if in bounds and add:</span>
                <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">item</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="p">:</span>
                    <span class="n">compIDs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_TACSWarning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Trying to add component ID of </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">, which</span><span class="se">\</span>
<span class="s2">                    is out of the range 0 &lt;= compID &lt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># This is a little inefficinet here; loop over</span>
                <span class="c1"># self.compDescripts and see if &#39;item&#39; (a string) in</span>
                <span class="c1"># part of the description. if so add.</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">compDescripts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">():</span>
                        <span class="n">compIDs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_TACSWarning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unidentifiable information given for &#39;include&#39;</span><span class="se">\</span>
<span class="s2">                or &#39;exclude&#39;. Valid data are integers 0 &lt;= i &lt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="si">}</span><span class="s2">, or </span><span class="se">\</span>
<span class="s2">                strings.&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;and&quot;</span><span class="p">:</span>
            <span class="c1"># First convert each entry to a set:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">compIDs</span><span class="p">)):</span>
                <span class="n">compIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">compIDs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># We want to go though and take only the intersection of</span>
            <span class="c1"># each of the sets we have found:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">compIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">compIDs</span><span class="p">)):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">compIDs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">compIDs</span> <span class="o">=</span> <span class="n">tmp</span>

        <span class="c1"># Finally convert to a list</span>
        <span class="n">compIDs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatten</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">compIDs</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">compIDs</span>

    <span class="k">def</span> <span class="nf">_createElements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elemCallBack</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create all the constitutive objects by calling the</span>
<span class="sd">        userSupplied or default callback function</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="p">):</span>

            <span class="c1"># Get a list of compDescripts to help the user</span>
            <span class="n">compDescript</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compDescripts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">numElements</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elemDescripts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="c1"># TACS component ID</span>
            <span class="n">compID</span> <span class="o">=</span> <span class="n">i</span>
            <span class="c1"># Nastran property ID</span>
            <span class="n">propID</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">property_ids</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Call the user function</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">elemCallBack</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span><span class="p">,</span>
                <span class="n">compID</span><span class="p">,</span>
                <span class="n">compDescript</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elemDescripts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">globalDVs</span><span class="p">,</span>
                <span class="n">propID</span><span class="o">=</span><span class="n">propID</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># For maximum flexibiliy, multiple pieces of information</span>
            <span class="c1"># can be returned. At a minimum, the element objects</span>
            <span class="c1"># must be returned!</span>

            <span class="c1"># Note: If two objects are returned, the</span>
            <span class="c1"># first one is used as the element object list and the</span>
            <span class="c1"># second one is treated as a scale list for the added dvs.</span>

            <span class="c1"># Check that result is an element object instance or .</span>
            <span class="n">foundElem</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">numFoundElements</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">scaleList</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">elemObjects</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
                    <span class="c1"># Iterable item, the scale list:</span>
                    <span class="n">scaleList</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
                    <span class="n">scaleList</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="c1"># Don&#39;t know what it is:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_TACSWarning</span><span class="p">(</span>
                        <span class="s2">&quot;Could not identify objects returned </span><span class="se">\</span>
<span class="s2">                    from elemCallBack. Valid return objects are: </span><span class="se">\</span>
<span class="s2">                    A list of TACS element objects (required, first), </span><span class="se">\</span>
<span class="s2">                    an iterable object </span><span class="se">\</span>
<span class="s2">                    (eg, list or array) containing the scaling parameters </span><span class="se">\</span>
<span class="s2">                    for the added design variables (optional, second). The </span><span class="se">\</span>
<span class="s2">                    string representation of the offending object is: </span><span class="se">\</span>
<span class="s2">                    &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span>
                        <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">elemObjects</span> <span class="o">=</span> <span class="n">result</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elemObjects</span><span class="p">,</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">Element</span><span class="p">):</span>
                <span class="c1"># There was only one element, recast it as a list and continue</span>
                <span class="n">elemObjects</span> <span class="o">=</span> <span class="p">[</span><span class="n">elemObjects</span><span class="p">]</span>
                <span class="n">numFoundElements</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elemObjects</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># Multiple elements were returned, count how many</span>
                <span class="k">for</span> <span class="nb">object</span> <span class="ow">in</span> <span class="n">elemObjects</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">Element</span><span class="p">):</span>
                        <span class="n">numFoundElements</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Object of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span><span class="si">}</span><span class="s2"> returned in elemCallBack function &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;is not a valid TACS element object. The </span><span class="se">\</span>
<span class="s2">                               string representation of the offending object is: </span><span class="se">\</span>
<span class="s2">                               &#39;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                        <span class="p">)</span>

            <span class="k">if</span> <span class="n">numFoundElements</span> <span class="o">!=</span> <span class="n">numElements</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unexpected number of element objects </span><span class="se">\</span>
<span class="s2">                    returned from user-supplied elemCallBack function. </span><span class="se">\</span>
<span class="s2">                    </span><span class="si">{</span><span class="n">numElements</span><span class="si">}</span><span class="s2"> element types (</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elemDescripts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="si">}</span><span class="s2">) are contained in Component </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, </span><span class="se">\</span>
<span class="s2">                    but </span><span class="si">{</span><span class="n">numFoundElements</span><span class="si">}</span><span class="s2"> element objects were returned by elemCallback.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Now determine the number of design variables. This is</span>
            <span class="c1"># NOT as simple as just getting the number of design</span>
            <span class="c1"># variables; Not all variables added in the conObject are</span>
            <span class="c1"># &#39;new&#39; variables, some of the variable number may have</span>
            <span class="c1"># been already used.</span>
            <span class="n">newVars</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">elemObject</span> <span class="ow">in</span> <span class="n">elemObjects</span><span class="p">:</span>
                <span class="n">dvs</span> <span class="o">=</span> <span class="n">elemObject</span><span class="o">.</span><span class="n">getDesignVarNums</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dvs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                    <span class="c1"># We will also check if the user screwed up. That is</span>
                    <span class="c1"># make sure that for added variables, the are</span>
                    <span class="c1"># continuous starting at self.dvNum</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">dvs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">var</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span><span class="p">:</span>
                            <span class="n">newVars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>

            <span class="c1"># Remove repeated dv nums from list</span>
            <span class="n">newVars</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">newVars</span><span class="p">)</span>
            <span class="n">newVars</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newVars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Now the length of newVars must the same as</span>
                <span class="c1"># newVars[-1]-newVars[0] + 1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">newVars</span><span class="p">)</span> <span class="o">==</span> <span class="n">newVars</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">newVars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                        <span class="s2">&quot;Inconsistent design variables detected. &quot;</span>
                        <span class="s2">&quot;The added design variables are not continuous.&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot; The added design variables are </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">newVars</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>

            <span class="c1"># Finally increment the dv counter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">newVars</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newVars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">scaleList</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">scaleList</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">newVars</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Make sure that the scaleList is the correct length.</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scaleList</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">newVars</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_TACSWarning</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;An incorrect number of scale variables </span><span class="se">\</span>
<span class="s2">                        were returned. There were </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">newVars</span><span class="p">)</span><span class="si">}</span><span class="s2"> variables added, but only </span><span class="se">\</span>
<span class="s2">                        </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">scaleList</span><span class="p">)</span><span class="si">}</span><span class="s2"> scale variables returned. The scale for these </span><span class="se">\</span>
<span class="s2">                        variables will be set to 1.0. The scale variables are </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">scaleList</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                        <span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">scaleList</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">newVars</span><span class="p">)))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">scaleList</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">scaleList</span><span class="p">)</span>

            <span class="c1"># Loop through every element type in this component,</span>
            <span class="c1"># there may be multiple (e.g CQUAD4 + CTRIA3)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">elemObject</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">elemObjects</span><span class="p">):</span>
                <span class="c1"># Set component-specific family id</span>
                <span class="n">elemObject</span><span class="o">.</span><span class="n">setComponentNum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compFam</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="c1"># Set each of the elements for this component</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">setElementObject</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">elemObject</span><span class="p">)</span>
                <span class="c1"># set varsPerNode</span>
                <span class="n">elemVarsPerNode</span> <span class="o">=</span> <span class="n">elemObject</span><span class="o">.</span><span class="n">getVarsPerNode</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">varsPerNode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">varsPerNode</span> <span class="o">=</span> <span class="n">elemVarsPerNode</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">varsPerNode</span> <span class="o">!=</span> <span class="n">elemVarsPerNode</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                        <span class="s2">&quot;Model references elements with differing numbers of variables per node &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">varsPerNode</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">elemVarsPerNode</span><span class="si">}</span><span class="s2">). &quot;</span>
                        <span class="s2">&quot;All elements must use same number of variables to be compatible.&quot;</span>
                    <span class="p">)</span>

        <span class="c1"># If varsPerNode still hasn&#39;t been set (because there were no elements added in the callback)</span>
        <span class="c1"># Default to 6</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">varsPerNode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">varsPerNode</span> <span class="o">=</span> <span class="mi">6</span>

    <span class="k">def</span> <span class="nf">_initializeError</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standard error print out if the user tries to call certain pytacs methods before intializing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
            <span class="s2">&quot;TACS assembler has not been created. &quot;</span>
            <span class="s2">&quot;Assembler must created first by running &#39;initalize&#39; method.&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">error</span></div>


<span class="k">def</span> <span class="nf">_tload2_get_load_at_time</span><span class="p">(</span><span class="n">tload2</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a function for interpolating the time series for the NASTRAN TLOAD2 card.</span>
<span class="sd">    Usually, this would be done through pyNastran, but there&#39;s bug in its implementation</span>
<span class="sd">    that prevents it from being run.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">time</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tload2</span><span class="o">.</span><span class="n">delay</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">tload2</span><span class="o">.</span><span class="n">delay</span>
    <span class="k">elif</span> <span class="n">tload2</span><span class="o">.</span><span class="n">delay</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">tload2</span><span class="o">.</span><span class="n">delay</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">tload2</span><span class="o">.</span><span class="n">delay_ref</span><span class="o">.</span><span class="n">get_delay_at_time</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

    <span class="n">t1</span> <span class="o">=</span> <span class="n">tload2</span><span class="o">.</span><span class="n">T1</span> <span class="o">+</span> <span class="n">tau</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">tload2</span><span class="o">.</span><span class="n">T2</span> <span class="o">+</span> <span class="n">tau</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">tload2</span><span class="o">.</span><span class="n">frequency</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">tload2</span><span class="o">.</span><span class="n">phase</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t1</span> <span class="o">&lt;=</span> <span class="n">time</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">scale</span>
        <span class="o">*</span> <span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="n">tload2</span><span class="o">.</span><span class="n">b</span>
        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">tload2</span><span class="o">.</span><span class="n">c</span> <span class="o">*</span> <span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">*</span> <span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">is_spcd</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># resp = f</span>
    <span class="k">if</span> <span class="n">tload2</span><span class="o">.</span><span class="n">Type</span> <span class="o">==</span> <span class="s2">&quot;VELO&quot;</span> <span class="ow">and</span> <span class="n">is_spcd</span><span class="p">:</span>
        <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tload2</span><span class="o">.</span><span class="n">us0</span>
    <span class="k">if</span> <span class="n">tload2</span><span class="o">.</span><span class="n">Type</span> <span class="o">==</span> <span class="s2">&quot;ACCE&quot;</span> <span class="ow">and</span> <span class="n">is_spcd</span><span class="p">:</span>
        <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tload2</span><span class="o">.</span><span class="n">vs0</span>
    <span class="k">return</span> <span class="n">f</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">TACS  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">tacs.pytacs</a></li> 
      </ul>
    </div>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>

  </body>
</html>