<!DOCTYPE html>

<html lang="python" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tacs.pytacs &#8212; TACS  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinxdoc.css?v=87629129" />
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
    <script src="../../_static/documentation_options.js?v=d048f138"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">TACS  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">tacs.pytacs</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for tacs.pytacs</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">pytacs - The Python wrapper for the TACS assembler</span>

<span class="sd">This python interface is designed to provide a easier interface to the</span>
<span class="sd">C++ layer of TACS. User-supplied hooks allow for nearly complete</span>
<span class="sd">customization of any or all parts in the problem setup. There are two</span>
<span class="sd">main parts of this module: The first deals with setting up the TACS</span>
<span class="sd">model including reading the mesh, setting elements and design variables.</span>
<span class="sd">The second part deals with creating problem instances that are responsible</span>
<span class="sd">for setting loads and functions, performing analysis, and gradient computations.</span>

<span class="sd">Developers:</span>
<span class="sd">    - Dr. G.K.W. Kenway (GKK)</span>
<span class="sd">    - Dr. T.R Brooks</span>

<span class="sd">History:</span>
<span class="sd">    - v. 1.0 pyTACS initial implementation</span>
<span class="sd">    - v. 3.0 updated TACS 3.0 pyTACS implementation</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># =============================================================================</span>
<span class="c1"># Imports</span>
<span class="c1"># =============================================================================</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pyNastran.bdf</span> <span class="k">as</span> <span class="nn">pn</span>

<span class="kn">import</span> <span class="nn">tacs.TACS</span>
<span class="kn">import</span> <span class="nn">tacs.constitutive</span>
<span class="kn">import</span> <span class="nn">tacs.constraints</span>
<span class="kn">import</span> <span class="nn">tacs.elements</span>
<span class="kn">import</span> <span class="nn">tacs.functions</span>
<span class="kn">import</span> <span class="nn">tacs.problems</span>
<span class="kn">from</span> <span class="nn">tacs.pymeshloader</span> <span class="kn">import</span> <span class="n">pyMeshLoader</span>
<span class="kn">from</span> <span class="nn">tacs.utilities</span> <span class="kn">import</span> <span class="n">BaseUI</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">)</span>


<span class="c1"># Define decorator functions for methods that must be called before initialize</span>
<span class="k">def</span> <span class="nf">preinitialize_method</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">method</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">` is a pre-initialize method. &quot;</span>
                <span class="s2">&quot;It may only be called before the &#39;initialize&#39; method has been called.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapped_method</span>


<span class="c1"># Define decorator functions for methods that must be called after initialize</span>
<span class="k">def</span> <span class="nf">postinitialize_method</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">method</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">` is a post-initialize method. &quot;</span>
                <span class="s2">&quot;It may only be called after the &#39;initialize&#39; method has been called.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapped_method</span>


<div class="viewcode-block" id="pyTACS">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS">[docs]</a>
<span class="k">class</span> <span class="nc">pyTACS</span><span class="p">(</span><span class="n">BaseUI</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The class for working with a TACS structure</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Default class options</span>
    <span class="n">defaultOptions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># Meshloader options</span>
        <span class="s2">&quot;printDebug&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">bool</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;Flag for whether to print debug information while loading file.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="c1"># Output Options</span>
        <span class="s2">&quot;outputElement&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">int</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;Specifies which element type should be written out in the f5 file.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> If None, the type will be inferred from the first element in the model.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> Acceptable values are:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.ELEMENT_NONE = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">ELEMENT_NONE</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.SCALAR_2D_ELEMENT = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">SCALAR_2D_ELEMENT</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.SCALAR_3D_ELEMENT = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">SCALAR_3D_ELEMENT</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.BEAM_OR_SHELL_ELEMENT = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">BEAM_OR_SHELL_ELEMENT</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.PLANE_STRESS_ELEMENT = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">PLANE_STRESS_ELEMENT</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.SOLID_ELEMENT = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">SOLID_ELEMENT</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.RIGID_ELEMENT = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">RIGID_ELEMENT</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.MASS_ELEMENT = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">MASS_ELEMENT</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.SPRING_ELEMENT = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">SPRING_ELEMENT</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="s2"> tacs.TACS.PCM_ELEMENT = </span><span class="si">{</span><span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">PCM_ELEMENT</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;writeConnectivity&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">bool</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;Flag for whether to include element connectivity in f5 file.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;writeNodes&quot;</span><span class="p">:</span> <span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;Flag for whether to include nodes in f5 file.&quot;</span><span class="p">],</span>
        <span class="s2">&quot;writeDisplacements&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">bool</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;Flag for whether to include nodal displacements in f5 file.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;writeStrains&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">bool</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;Flag for whether to include element strains in f5 file.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;writeStresses&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">bool</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;Flag for whether to include element stresses in f5 file.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;writeExtras&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">bool</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;Flag for whether to include element extra variables in f5 file.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;writeLoads&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">bool</span><span class="p">,</span>
            <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;Flag for whether to include external nodal loads in f5 file.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;writeCoordinateFrame&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">bool</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;Flag for whether to include element coordinate frames in f5 file.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;familySeparator&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">str</span><span class="p">,</span>
            <span class="s2">&quot;/&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Family separator character used for condensing groups in f5 file.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;printTiming&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">bool</span><span class="p">,</span>
            <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;Flag for printing out timing information for class procedures.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="s2">&quot;linearityTol&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="nb">float</span><span class="p">,</span>
            <span class="mf">1e-14</span><span class="p">,</span>
            <span class="s2">&quot;When created, pyTACS will check if the model is linear or nonlinear by checking whether (res(2*u) - res(0)) - 2 * (res(u) - res(0)) == 0 this tolerance controls how close to zero the residual must be to be considered linear.&quot;</span><span class="p">,</span>
        <span class="p">],</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bdf</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dvNum</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scaleList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bdf : str or pyNastran.bdf.bdf.BDF</span>
<span class="sd">            The BDF file or a pyNastran BDF object to load.</span>

<span class="sd">        comm : mpi4py.MPI.Intracomm</span>
<span class="sd">            The comm object on which to create the pyTACS object.</span>

<span class="sd">        dvNum : int</span>
<span class="sd">            A user-supplied offset to the design variable</span>
<span class="sd">            numbering. This is typically used with tacs+tripan when</span>
<span class="sd">            geometric variables have already been added and assigned</span>
<span class="sd">            global tacs numberings.</span>

<span class="sd">        scaleList: list</span>
<span class="sd">            when dvNum is non-zero, the scaleList must be same size</span>
<span class="sd">            as the number of design variables already added. i.e.</span>
<span class="sd">            len(scaleList) = dvNum</span>

<span class="sd">        options : dict</span>
<span class="sd">            Dictionary holding model-specific option parameters (case-insensitive).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">startTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># Setup comm and options</span>
        <span class="n">BaseUI</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">)</span>

        <span class="n">importTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># Create and load mesh loader object.</span>
        <span class="n">debugFlag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;printDebug&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span> <span class="o">=</span> <span class="n">pyMeshLoader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span> <span class="n">debugFlag</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">scanBdfFile</span><span class="p">(</span><span class="n">bdf</span><span class="p">)</span>
        <span class="c1"># Save pynastran bdf object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getBDFInfo</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bdfName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">bdf_filename</span>

        <span class="n">meshLoadTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># Retrieve the number of components. This is the maximum</span>
        <span class="c1"># number of unique constitutive objects possible in this model.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nComp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getNumComponents</span><span class="p">()</span>

        <span class="c1"># Load all the component descriptions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compDescripts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getComponentDescripts</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elemDescripts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getElementDescripts</span><span class="p">()</span>

        <span class="c1"># Set the starting dvNum and scaleList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span> <span class="o">=</span> <span class="n">dvNum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaleList</span> <span class="o">=</span> <span class="n">scaleList</span>
        <span class="k">if</span> <span class="n">scaleList</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scaleList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">DVPreprocTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># List of DV groups</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">globalDVs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">massDVs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compIDBounds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addedCompIDs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># List of initial coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xpts0</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># List of initial designvars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Design var upper/lower-bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xub</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xlb</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Variables per node for model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">varsPerNode</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># TACS assembler object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Nonlinear flag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_isNonlinear</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">initFinishTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;printTiming&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span><span class="s2">&quot;+--------------------------------------------------+&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span><span class="s2">&quot;| TACS Init Times:&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span>
                <span class="s2">&quot;| </span><span class="si">%-30s</span><span class="s2">: </span><span class="si">%10.3f</span><span class="s2"> sec&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;TACS Module Time&quot;</span><span class="p">,</span> <span class="n">importTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span>
                <span class="s2">&quot;| </span><span class="si">%-30s</span><span class="s2">: </span><span class="si">%10.3f</span><span class="s2"> sec&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;TACS Meshload Time&quot;</span><span class="p">,</span> <span class="n">meshLoadTime</span> <span class="o">-</span> <span class="n">importTime</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span>
                <span class="s2">&quot;| </span><span class="si">%-30s</span><span class="s2">: </span><span class="si">%10.3f</span><span class="s2"> sec&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;TACS DV Processing Time&quot;</span><span class="p">,</span> <span class="n">DVPreprocTime</span> <span class="o">-</span> <span class="n">meshLoadTime</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span>
                <span class="s2">&quot;| </span><span class="si">%-30s</span><span class="s2">: </span><span class="si">%10.3f</span><span class="s2"> sec&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;TACS Finalize Initialization Time&quot;</span><span class="p">,</span> <span class="n">initFinishTime</span> <span class="o">-</span> <span class="n">DVPreprocTime</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span>
                <span class="s2">&quot;| </span><span class="si">%-30s</span><span class="s2">: </span><span class="si">%10.3f</span><span class="s2"> sec&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;TACS Total Initialization Time&quot;</span><span class="p">,</span> <span class="n">initFinishTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">(</span><span class="s2">&quot;+--------------------------------------------------+&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isNonlinear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The public interface for the isNonlinear attribute. Implemented as a property so that it is read-only.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isNonlinear</span>

<div class="viewcode-block" id="pyTACS.addGlobalDV">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.addGlobalDV">[docs]</a>
    <span class="nd">@preinitialize_method</span>
    <span class="k">def</span> <span class="nf">addGlobalDV</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">descript</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a global design variable that can affect multiple components.</span>

<span class="sd">        This function allows adding design variables that are not</span>
<span class="sd">        cleanly associated with a particular constitutive object. One</span>
<span class="sd">        example is the pitch of the stiffeners for blade-stiffened</span>
<span class="sd">        panels. It is often the same for many different constitutive</span>
<span class="sd">        objects. By calling this function, the internal dvNum counter</span>
<span class="sd">        is incremented, and the user doesn&#39;t have to worry about</span>
<span class="sd">        it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        descript : str</span>
<span class="sd">            A user-supplied string that can be used to retrieve the</span>
<span class="sd">            variable number and value elemCallBackFunction.</span>
<span class="sd">        value : float</span>
<span class="sd">            Initial value for variable.</span>
<span class="sd">        lower : float</span>
<span class="sd">            Lower bound. This may be None for unbounded</span>
<span class="sd">        upper : float</span>
<span class="sd">            Upper bound. This may be None for unbounded</span>
<span class="sd">        scale : float</span>
<span class="sd">            Scale factor for variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">globalDVs</span><span class="p">[</span><span class="n">descript</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;num&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span><span class="p">,</span>
            <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span>
            <span class="s2">&quot;lowerBound&quot;</span><span class="p">:</span> <span class="n">lower</span><span class="p">,</span>
            <span class="s2">&quot;upperBound&quot;</span><span class="p">:</span> <span class="n">upper</span><span class="p">,</span>
            <span class="s2">&quot;isMassDV&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaleList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span></div>


<div class="viewcode-block" id="pyTACS.getGlobalDVs">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getGlobalDVs">[docs]</a>
    <span class="k">def</span> <span class="nf">getGlobalDVs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return dict holding info about all current global DVs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        globalDVs : dict</span>
<span class="sd">            Dictionary holding global dv information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">globalDVs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="pyTACS.getGlobalDVKeys">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getGlobalDVKeys">[docs]</a>
    <span class="k">def</span> <span class="nf">getGlobalDVKeys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get key names for all current global DVs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        globalDVKeys : list[str]</span>
<span class="sd">            List holding global dv names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">globalDVs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


<div class="viewcode-block" id="pyTACS.getGlobalDVNums">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getGlobalDVNums">[docs]</a>
    <span class="k">def</span> <span class="nf">getGlobalDVNums</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the dv nums corresponding to global DVs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        globalDVNums : list[int]</span>
<span class="sd">            List holding dv nums corresponding to global DVs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">globalDVs</span><span class="p">[</span><span class="n">descript</span><span class="p">][</span><span class="s2">&quot;num&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">descript</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">globalDVs</span><span class="p">]</span></div>


<div class="viewcode-block" id="pyTACS.getTotalNumGlobalDVs">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getTotalNumGlobalDVs">[docs]</a>
    <span class="k">def</span> <span class="nf">getTotalNumGlobalDVs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the total number of global DVs across all processors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        globalDVs : dict</span>
<span class="sd">            Dictionary holding global dv information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">globalDVs</span><span class="p">)</span></div>


<div class="viewcode-block" id="pyTACS.assignMassDV">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.assignMassDV">[docs]</a>
    <span class="nd">@preinitialize_method</span>
    <span class="k">def</span> <span class="nf">assignMassDV</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">descript</span><span class="p">,</span> <span class="n">eIDs</span><span class="p">,</span> <span class="n">dvName</span><span class="o">=</span><span class="s2">&quot;m&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign a global DV to a point mass element.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        descript : str</span>
<span class="sd">            Global DV key to assign mass design variable to. If the key is does not exist,</span>
<span class="sd">            it will automatically be created and added to global DVs.</span>

<span class="sd">        eIDs : int or list[int]</span>
<span class="sd">            Element IDs of concentrated mass to assign DV to (NASTRAN ordering)</span>

<span class="sd">        dvName : str</span>
<span class="sd">            Name of mass property to apply DV to.</span>
<span class="sd">            May be `m` for mass, `I11`, `I22`, `I12`, etc. for moment of inertia components.</span>
<span class="sd">            Defaults to `m` (mass).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Currently only CONM2 cards are supported.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure eID is an array</span>
        <span class="n">eIDs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">eIDs</span><span class="p">)</span>

        <span class="c1"># Check if referenced element ID is a CONM2 element</span>
        <span class="k">for</span> <span class="n">eID</span> <span class="ow">in</span> <span class="n">eIDs</span><span class="p">:</span>
            <span class="n">is_mass_element</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">eID</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">masses</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">masses</span><span class="p">[</span><span class="n">eID</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CONM2&quot;</span><span class="p">]:</span>
                    <span class="n">is_mass_element</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_mass_element</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Element ID &#39;</span><span class="si">{</span><span class="n">eID</span><span class="si">}</span><span class="s2">&#39; does not correspond to a `CONM2` element. &quot;</span>
                    <span class="s2">&quot;Only `CONM2` elements are supported for this method.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Check if descript already exists in global dvs, if not add it</span>
        <span class="k">if</span> <span class="n">descript</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">globalDVs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addGlobalDV</span><span class="p">(</span><span class="n">descript</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">dv_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">globalDVs</span><span class="p">[</span><span class="n">descript</span><span class="p">]</span>

        <span class="c1"># Flag this global dv as being a mass dv</span>
        <span class="n">dv_dict</span><span class="p">[</span><span class="s2">&quot;isMassDV&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">massDV</span> <span class="o">=</span> <span class="n">dv_dict</span><span class="p">[</span><span class="s2">&quot;num&quot;</span><span class="p">]</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">dv_dict</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
        <span class="n">ub</span> <span class="o">=</span> <span class="n">dv_dict</span><span class="p">[</span><span class="s2">&quot;upperBound&quot;</span><span class="p">]</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="n">dv_dict</span><span class="p">[</span><span class="s2">&quot;lowerBound&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">eID</span> <span class="ow">in</span> <span class="n">eIDs</span><span class="p">:</span>
            <span class="c1"># If the element ID hasn&#39;t already been added to massDVs, add it</span>
            <span class="k">if</span> <span class="n">eID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">massDVs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">massDVs</span><span class="p">[</span><span class="n">eID</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># Update the element entry with the dv num</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">massDVs</span><span class="p">[</span><span class="n">eID</span><span class="p">][</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dvName</span><span class="si">}</span><span class="s2">Num&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">massDV</span>

            <span class="c1"># Update the element entry with the dv name</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">massDVs</span><span class="p">[</span><span class="n">eID</span><span class="p">][</span><span class="n">dvName</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="c1"># If value was defined from previous call, remove it</span>
            <span class="k">elif</span> <span class="n">dvName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">massDVs</span><span class="p">[</span><span class="n">eID</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">massDVs</span><span class="p">[</span><span class="n">eID</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">dvName</span><span class="p">)</span>

            <span class="c1"># Update the element entry with the dv upper bound</span>
            <span class="k">if</span> <span class="n">ub</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">massDVs</span><span class="p">[</span><span class="n">eID</span><span class="p">][</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dvName</span><span class="si">}</span><span class="s2">ub&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ub</span>
            <span class="c1"># If upper bound was defined from previous call, remove it</span>
            <span class="k">elif</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dvName</span><span class="si">}</span><span class="s2">ub&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">massDVs</span><span class="p">[</span><span class="n">eID</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">massDVs</span><span class="p">[</span><span class="n">eID</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dvName</span><span class="si">}</span><span class="s2">ub&quot;</span><span class="p">)</span>

            <span class="c1"># Update the element entry with the dv lower bound</span>
            <span class="k">if</span> <span class="n">lb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">massDVs</span><span class="p">[</span><span class="n">eID</span><span class="p">][</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dvName</span><span class="si">}</span><span class="s2">lb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lb</span>
            <span class="c1"># If lower bound was defined from previous call, remove it</span>
            <span class="k">elif</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dvName</span><span class="si">}</span><span class="s2">lb&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">massDVs</span><span class="p">[</span><span class="n">eID</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">massDVs</span><span class="p">[</span><span class="n">eID</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dvName</span><span class="si">}</span><span class="s2">lb&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="pyTACS.selectCompIDs">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.selectCompIDs">[docs]</a>
    <span class="k">def</span> <span class="nf">selectCompIDs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">include</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">includeBounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nGroup</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">includeOp</span><span class="o">=</span><span class="s2">&quot;or&quot;</span><span class="p">,</span>
        <span class="n">excludeOp</span><span class="o">=</span><span class="s2">&quot;or&quot;</span><span class="p">,</span>
        <span class="n">projectVector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the most important function of the entire setup</span>
<span class="sd">        process.</span>
<span class="sd">        The basic idea is as follows: We have a list of nComp</span>
<span class="sd">        which are the component descriptions.</span>
<span class="sd">        What we need is a way of</span>
<span class="sd">        generating subgroups of these for the purposes of adding</span>
<span class="sd">        design variables, constitutive objects, KS domains, and mass</span>
<span class="sd">        domains.</span>
<span class="sd">        All of these operations boil down to selecting a</span>
<span class="sd">        subset of the compIDs.</span>

<span class="sd">        This function attempts to support as many ways as possible to</span>
<span class="sd">        select parts of the structure.</span>
<span class="sd">        Easy and efficient selection of</span>
<span class="sd">        parts is critical to the end user.</span>

<span class="sd">        Methods of selection:</span>

<span class="sd">        1. include, integer, string, list of integers and/or strings: The</span>
<span class="sd">        simplest and most direct way of selecting a component.</span>
<span class="sd">        The</span>
<span class="sd">        user supplies the index of the componentID, a name or partial</span>
<span class="sd">        name, or a list containing a combination of both.</span>

<span class="sd">        For example::</span>

<span class="sd">            # Select the 11th component</span>
<span class="sd">            selectCompIDs(include=10)</span>

<span class="sd">            # Select the first and fifth component</span>
<span class="sd">            selectCompIDs(include=[0, 4])</span>

<span class="sd">            # Select any component containing &#39;rib.00&#39;</span>
<span class="sd">            selectCompIDs(include=&#39;rib.00&#39;)</span>

<span class="sd">            # Select any components containing &#39;rib.00&#39; and &#39;rib.10&#39;</span>
<span class="sd">            selectCompIDs(include=[&#39;rib.00&#39;, &#39;rib.10&#39;])</span>

<span class="sd">            # Select any component containing &#39;rib.00&#39;, the 11th</span>
<span class="sd">            # component and any component containing &#39;spar&#39;</span>
<span class="sd">            # (This is probably not advisable!)</span>
<span class="sd">            selectCompIDs(include=[&#39;rib.00&#39;, 10, &#39;spar&#39;])</span>

<span class="sd">        2. Exclude, operates similarly to &#39;include&#39;.</span>
<span class="sd">        The behaviour of exclude is identical to include above, except that</span>
<span class="sd">        component ID&#39;s that are found using &#39;exclude&#39; are</span>
<span class="sd">        &#39;subtracted&#39; from those found using include.</span>
<span class="sd">        A special case is treated if &#39;include&#39; is NOT given: if only an</span>
<span class="sd">        exclude list is given, this implies the selection of all</span>
<span class="sd">        compID&#39;s EXCEPT the those in exclude.</span>

<span class="sd">        For example::</span>

<span class="sd">            # This will return will [0, 1, 2, 3, 5, ..., nComp-1]</span>
<span class="sd">            selectCompIDs(exclude = 4)</span>

<span class="sd">            # This will return [0, 1, 4, 5, ..., nComp-1]</span>
<span class="sd">            selectCompIDs(exclude = [2, 3]) will return</span>

<span class="sd">            # This will return components that have &#39;ribs&#39; in the</span>
<span class="sd">            # component ID, but not those that have &#39;le_ribs&#39; in the</span>
<span class="sd">            # component id.</span>
<span class="sd">            selectCompIDs(include=&#39;ribs&#39;, exclude=&#39;le_ribs&#39;)</span>

<span class="sd">        3. includeBounds, list of components defining a region inside</span>
<span class="sd">        which &#39;include&#39; components will be selected.</span>
<span class="sd">        This functionality uses a geometric approach to select the compIDs.</span>
<span class="sd">        All components within the project 2D convex hull are included.</span>
<span class="sd">        Therefore, it is essential to split up concave include regions</span>
<span class="sd">        into smaller convex regions.</span>
<span class="sd">        Use multiple calls to selectCompIDs to accumulate multiple regions.</span>

<span class="sd">        For example::</span>

<span class="sd">            # This will select upper skin components between the</span>
<span class="sd">            # leading and trailing edge spars and between ribs 1 and 4.</span>
<span class="sd">            selectCompIDs(include=&#39;U_SKIN&#39;, includeBound=</span>
<span class="sd">                [&#39;LE_SPAR&#39;, &#39;TE_SPAR&#39;, &#39;RIB.01&#39;, &#39;RIB.04&#39;])</span>

<span class="sd">        4. nGroup: The number of groups to divide the found components</span>
<span class="sd">        into.</span>
<span class="sd">        Generally this will be 1. However, in certain cases, it</span>
<span class="sd">        is convenient to create multiple groups in one pass.</span>

<span class="sd">        For example::</span>

<span class="sd">            # This will &#39;evenly&#39; create 10 groups on all components</span>
<span class="sd">            # containing LE_SPAR.</span>
<span class="sd">            Note that once the components are</span>
<span class="sd">            # selected, they are sorted **alphabetically** and assigned</span>
<span class="sd">            # sequentially.</span>
<span class="sd">            selectCompIDs(include=&#39;LE_SPAR&#39;, nGroup=10)</span>

<span class="sd">        nGroup can also be negative.</span>
<span class="sd">        If it is negative, then a single</span>
<span class="sd">        design variable group is added to each of the found</span>
<span class="sd">        components.</span>

<span class="sd">        For example::</span>

<span class="sd">            # will select all components and assign a design variable</span>
<span class="sd">            # group to each one.</span>
<span class="sd">            selectCompIDs(nGroup=-1)</span>

<span class="sd">        includeOp, str: &#39;and&#39; or &#39;or&#39;.</span>
<span class="sd">        Selects the logical operation</span>
<span class="sd">        used for item in &#39;include&#39; option.</span>
<span class="sd">        For example:</span>

<span class="sd">        selectCompIDs(include=[&#39;LE_SPAR&#39;, &#39;TE_SPAR&#39;],</span>
<span class="sd">        includeOpt=&#39;or&#39;) will select the LE_SPAR and TE_SPAR</span>
<span class="sd">        components (default behaviour).</span>

<span class="sd">        selectCompIDs(include=[&#39;RIB&#39;, &#39;SEG.01&#39;], includeOpt=&#39;and&#39;)</span>
<span class="sd">        will select any component with &#39;RIB&#39; in the description AND</span>
<span class="sd">        &#39;SEG.01&#39; in the description.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Defaults</span>
        <span class="n">includeIDs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="p">)</span>
        <span class="n">excludeIDs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">includeBoundIDs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">include</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">includeIDs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getCompIDs</span><span class="p">(</span><span class="n">includeOp</span><span class="p">,</span> <span class="n">include</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">excludeIDs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getCompIDs</span><span class="p">(</span><span class="n">excludeOp</span><span class="p">,</span> <span class="n">exclude</span><span class="p">)</span>

        <span class="n">iSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">includeIDs</span><span class="p">)</span>
        <span class="n">eSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">excludeIDs</span><span class="p">)</span>

        <span class="c1"># First take the intersection of iSet and ibSet</span>
        <span class="k">if</span> <span class="n">includeBoundIDs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">iSet</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">includeBoundIDs</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">iSet</span>

        <span class="c1"># Next take the difference between tmp and eSet</span>
        <span class="n">compIDs</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">eSet</span><span class="p">)</span>

        <span class="c1"># Convert back to a list:</span>
        <span class="n">compIDs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">compIDs</span><span class="p">)</span>

        <span class="c1"># If we only want a single group, we&#39;re done, otherwise, we</span>
        <span class="c1"># have a bit more work to do...</span>
        <span class="k">if</span> <span class="n">nGroup</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># The user wants to have nGroups returned from compIDs.</span>

            <span class="c1"># First check that nGroup &lt;= len(compIDs), print warning</span>
            <span class="c1"># and clip if not</span>
            <span class="k">if</span> <span class="n">nGroup</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">compIDs</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_TACSWarning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;nGroup=</span><span class="si">{</span><span class="n">nGroup</span><span class="si">}</span><span class="s2"> is larger than the number of</span><span class="se">\</span>
<span class="s2">                selected components=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">compIDs</span><span class="p">)</span><span class="si">}</span><span class="s2">. nGroup will be clipped to </span><span class="si">{</span><span class="n">nGroup</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">nGroup</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">compIDs</span><span class="p">)</span>

            <span class="c1"># Pluck out the component descriptions again and we will</span>
            <span class="c1"># sort them</span>
            <span class="n">compDescript</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">compIDs</span><span class="p">)):</span>
                <span class="n">compDescript</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compDescripts</span><span class="p">[</span><span class="n">compIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

            <span class="c1"># define a general argsort</span>
            <span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="n">seq</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">)</span>

            <span class="c1"># ind is the index that would result in a sorted list.</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">compDescript</span><span class="p">)</span>

            <span class="c1"># Now simply divide &#39;ind&#39; into &#39;nGroups&#39; as evenly as</span>
            <span class="c1"># possible, in the integer sense.</span>
            <span class="k">def</span> <span class="nf">split_list</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span> <span class="n">wanted_parts</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">[</span>
                    <span class="n">alist</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">length</span> <span class="o">//</span> <span class="n">wanted_parts</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">length</span> <span class="o">//</span> <span class="n">wanted_parts</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wanted_parts</span><span class="p">)</span>
                <span class="p">]</span>

            <span class="n">ind</span> <span class="o">=</span> <span class="n">split_list</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">nGroup</span><span class="p">)</span>

            <span class="c1"># Finally assemble the nested list of component IDs</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)):</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                    <span class="n">tmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compIDs</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]])</span>
            <span class="n">compIDs</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">elif</span> <span class="n">nGroup</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Negative number signifies &#39;add one dv to each component&#39;</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">compIDs</span><span class="p">:</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">comp</span><span class="p">])</span>
            <span class="n">compIDs</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Otherwise, just put the current list of compIDs in a</span>
            <span class="c1"># list of length 1.</span>
            <span class="n">compIDs</span> <span class="o">=</span> <span class="p">[</span><span class="n">compIDs</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">compIDs</span></div>


<div class="viewcode-block" id="pyTACS.getBDFInfo">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getBDFInfo">[docs]</a>
    <span class="k">def</span> <span class="nf">getBDFInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a pynastran bdf object.</span>
<span class="sd">        This object can be used interactively</span>
<span class="sd">        to parse information (nodes, elements, loads, etc.) included in the bdf file.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bdfInfo : pyNastran.bdf.bdf.BDF</span>
<span class="sd">            pyNastran bdf object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span></div>


<div class="viewcode-block" id="pyTACS.getCompNames">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getCompNames">[docs]</a>
    <span class="k">def</span> <span class="nf">getCompNames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compIDs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of component descriptions for the given component</span>
<span class="sd">        IDs. compIDs should come from a call to selectCompIDs</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compIDs : int or list[int] or None</span>
<span class="sd">            List of integers containing the compIDs numbers. If None, returns names for all components.</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        compDescript : list[str]</span>
<span class="sd">            List of strings containing the names of the corresponding compIDs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Return all component names</span>
        <span class="k">if</span> <span class="n">compIDs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compDescripts</span><span class="p">)</span>
        <span class="c1"># Convert to list</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compIDs</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
            <span class="n">compIDs</span> <span class="o">=</span> <span class="p">[</span><span class="n">compIDs</span><span class="p">]</span>
        <span class="c1"># Make sure list is flat</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compIDs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatten</span><span class="p">(</span><span class="n">compIDs</span><span class="p">)</span>

        <span class="n">compDescripts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">compIDs</span><span class="p">)):</span>
            <span class="n">compDescripts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compDescripts</span><span class="p">[</span><span class="n">compIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">compDescripts</span></div>


<div class="viewcode-block" id="pyTACS.getGlobalNodeIDsForComps">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getGlobalNodeIDsForComps">[docs]</a>
    <span class="k">def</span> <span class="nf">getGlobalNodeIDsForComps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compIDs</span><span class="p">,</span> <span class="n">nastranOrdering</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the global (non-partitioned) node IDs belonging to a given list of component IDs</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compIDs : int or list[int] or None</span>
<span class="sd">            List of integers containing the compIDs numbers.</span>
<span class="sd">            If None, returns nodeIDs for all components.</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">        nastranOrdering : bool</span>
<span class="sd">            Flag signaling whether nodeIDs are in TACS (default) or NASTRAN (grid IDs in bdf file) ordering</span>
<span class="sd">            Defaults to False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nodeIDs : list[int]</span>
<span class="sd">            List of unique nodeIDs that belong to the given list of compIDs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Return all component ids</span>
        <span class="k">if</span> <span class="n">compIDs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">compIDs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getGlobalNodeIDsForComps</span><span class="p">(</span><span class="n">compIDs</span><span class="p">,</span> <span class="n">nastranOrdering</span><span class="p">)</span></div>


<div class="viewcode-block" id="pyTACS.getLocalNodeIDsForComps">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getLocalNodeIDsForComps">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">getLocalNodeIDsForComps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compIDs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the local (partitioned) node IDs belonging to a given list of component IDs</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">         compIDs : int or list[int] or None</span>
<span class="sd">            List of integers containing the compIDs numbers.</span>
<span class="sd">            If None, returns nodeIDs for all components.</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nodeIDs : list[int]</span>
<span class="sd">            List of unique nodeIDs that belong to the given list of compIDs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Return all component ids</span>
        <span class="k">if</span> <span class="n">compIDs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">compIDs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getLocalNodeIDsForComps</span><span class="p">(</span><span class="n">compIDs</span><span class="p">)</span></div>


<div class="viewcode-block" id="pyTACS.getLocalNodeIDsFromGlobal">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getLocalNodeIDsFromGlobal">[docs]</a>
    <span class="k">def</span> <span class="nf">getLocalNodeIDsFromGlobal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">globalIDs</span><span class="p">,</span> <span class="n">nastranOrdering</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a list of node IDs in global (non-partitioned) ordering</span>
<span class="sd">        returns the local (partitioned) node IDs on each processor.</span>
<span class="sd">        If a requested node is not included on this processor,</span>
<span class="sd">        an entry of -1 will be returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        globalIDs : int or list[int]</span>
<span class="sd">            List of global node IDs.</span>

<span class="sd">        nastranOrdering : bool</span>
<span class="sd">            Flag signaling whether globalIDs is in TACS (default) or NASTRAN (grid IDs in bdf file) ordering</span>
<span class="sd">            Defaults to False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        localIDs : list[int]</span>
<span class="sd">            List of local node IDs for each entry in globalIDs.</span>
<span class="sd">            If the node is not owned by this processor, its index is filled with a value of -1.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getLocalNodeIDsFromGlobal</span><span class="p">(</span><span class="n">globalIDs</span><span class="p">,</span> <span class="n">nastranOrdering</span><span class="p">)</span></div>


<div class="viewcode-block" id="pyTACS.initialize">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.initialize">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elemCallBack</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the &#39;last&#39; method to be called during the setup. The</span>
<span class="sd">        user should have already added all the design variables,</span>
<span class="sd">        domains, etc. Before this function is called. This function</span>
<span class="sd">        finalizes the problem initialization and cannot be changed at</span>
<span class="sd">        later time. If the user does not provide an elemCallBack function,</span>
<span class="sd">        we will use pyNastran to generate one automatically from element</span>
<span class="sd">        properties provided in the BDF file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elemCallBack : collections.abc.Callable or None</span>

<span class="sd">           The calling sequence for elemCallBack **must** be as</span>
<span class="sd">           follows::</span>

<span class="sd">             def elemCallBack(dvNum, compID, compDescript, elemDescripts,</span>
<span class="sd">                             globalDVs, **kwargs):</span>

<span class="sd">           The dvNum is the current counter which must be used by the</span>
<span class="sd">           user when creating a constitutive object with design</span>
<span class="sd">           variables.</span>

<span class="sd">           compID is the ID number used by tacs to reference this property group.</span>
<span class="sd">           Use kwargs[&#39;propID&#39;] to get the corresponding Nastran property ID that</span>
<span class="sd">           is read in from the BDF.</span>

<span class="sd">           compDescript is the component description label read in from optional</span>
<span class="sd">           formatted comments in BDF file</span>

<span class="sd">           elemDescripts are the name of the elements belonging to this group</span>
<span class="sd">           (e.g. CQUAD4, CTRIA3, CTETRA, etc). This value will be a list since</span>
<span class="sd">           one component may contain multiple compatible element types.</span>
<span class="sd">           Example: [&#39;CQUAD4&#39;, CTRIA3&#39;]</span>

<span class="sd">           globalDVs is a dictionary containing information about any</span>
<span class="sd">           global DVs that have been added.</span>

<span class="sd">           elemCallBack must return a list containing as many TACS element</span>
<span class="sd">           objects as there are element types in elemDescripts (one for each).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">elemCallBack</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">elemCallBack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elemCallBackFromBDF</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_createOutputGroups</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_createElements</span><span class="p">(</span><span class="n">elemCallBack</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">createTACSAssembler</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">varsPerNode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">massDVs</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_createOutputViewer</span><span class="p">()</span>

        <span class="c1"># Store original node locations read in from bdf file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xpts0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createNodeVec</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">getNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xpts0</span><span class="p">)</span>

        <span class="c1"># Store initial design variable values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createDesignVec</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">getDesignVars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span>

        <span class="c1"># Store design variable upper/lower-bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createDesignVec</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xlb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createDesignVec</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">getDesignVarRange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xlb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xub</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_isNonlinear</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkNonlinearity</span><span class="p">()</span></div>


    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">_checkNonlinearity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the finite element model is nonlinear</span>

<span class="sd">        This check works by checking whether the residual is nonlinear w.r.t the states using 3 residual evaluations.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if the problem is nonlinear, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createVec</span><span class="p">()</span>
        <span class="n">res1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createVec</span><span class="p">()</span>
        <span class="n">res2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createVec</span><span class="p">()</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createVec</span><span class="p">()</span>

        <span class="c1"># Evaluate r(0)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">zeroEntries</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">setVariables</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">assembleRes</span><span class="p">(</span><span class="n">res0</span><span class="p">)</span>

        <span class="c1"># Evaluate r(u) - r(0)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">initRand</span><span class="p">()</span>
        <span class="n">state</span><span class="o">.</span><span class="n">setRand</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setBCsInVec</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">setVariables</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">assembleRes</span><span class="p">(</span><span class="n">res1</span><span class="p">)</span>
        <span class="n">res1</span><span class="o">.</span><span class="n">axpy</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">res0</span><span class="p">)</span>

        <span class="c1"># Evaluate r(2u) -  r(0)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setBCsInVec</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">setVariables</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">assembleRes</span><span class="p">(</span><span class="n">res2</span><span class="p">)</span>
        <span class="n">res2</span><span class="o">.</span><span class="n">axpy</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">res0</span><span class="p">)</span>

        <span class="c1"># Reset the state variables</span>
        <span class="n">state</span><span class="o">.</span><span class="n">zeroEntries</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">setVariables</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="c1"># Check if (res2-res0) - 2 * (res1 - res0) is zero (or very close to it)</span>
        <span class="n">resNorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">res1</span><span class="o">.</span><span class="n">norm</span><span class="p">())</span>
        <span class="n">res2</span><span class="o">.</span><span class="n">axpy</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">res1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">resNorm</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">res2</span><span class="o">.</span><span class="n">norm</span><span class="p">())</span> <span class="o">/</span> <span class="n">resNorm</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span>
            <span class="s2">&quot;linearityTol&quot;</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># not nonlinear case</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># nonlinear case</span>

    <span class="k">def</span> <span class="nf">_elemCallBackFromBDF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automatically setup elemCallBack using information contained in BDF file.</span>
<span class="sd">        This function assumes all material properties are specified in the BDF.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if any properties are in the BDF</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">missing_properties</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;BDF file &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bdfName</span><span class="si">}</span><span class="s2">&#39; has missing properties cards. &quot;</span>
                <span class="s2">&quot;Set &#39;printDebug&#39; option to True for more information. &quot;</span>
                <span class="s2">&quot;User must define own elemCallBack function.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Make sure cross-referencing is turned on in pynastran</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">is_xrefed</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">cross_reference</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">is_xrefed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Create a dictionary to sort all elements by property number</span>
        <span class="n">elemDict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">elementID</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
            <span class="n">element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">elementID</span><span class="p">]</span>
            <span class="n">propertyID</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">pid</span>
            <span class="k">if</span> <span class="n">propertyID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elemDict</span><span class="p">:</span>
                <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

        <span class="c1"># Create a dictionary to sort all design variables</span>
        <span class="k">for</span> <span class="n">dv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">dvprels</span><span class="p">:</span>
            <span class="n">propertyID</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">dvprels</span><span class="p">[</span><span class="n">dv</span><span class="p">]</span><span class="o">.</span><span class="n">pid</span>
            <span class="n">dvName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">dvprels</span><span class="p">[</span><span class="n">dv</span><span class="p">]</span><span class="o">.</span><span class="n">pname_fid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">dvprels</span><span class="p">[</span><span class="n">dv</span><span class="p">]</span><span class="o">.</span><span class="n">dvids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="n">dvName</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">dvprels</span><span class="p">[</span><span class="n">dv</span><span class="p">]</span>
        <span class="c1"># Create option for user to specify scale values in BDF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaleList</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span>

        <span class="c1"># Callback function to return appropriate tacs MaterialProperties object</span>
        <span class="c1"># For a pynastran mat card</span>
        <span class="k">def</span> <span class="nf">matCallBack</span><span class="p">(</span><span class="n">matInfo</span><span class="p">):</span>
            <span class="c1"># Nastran isotropic material card</span>
            <span class="k">if</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;MAT1&quot;</span><span class="p">:</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">MaterialProperties</span><span class="p">(</span>
                    <span class="n">rho</span><span class="o">=</span><span class="n">matInfo</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span>
                    <span class="n">E</span><span class="o">=</span><span class="n">matInfo</span><span class="o">.</span><span class="n">e</span><span class="p">,</span>
                    <span class="n">nu</span><span class="o">=</span><span class="n">matInfo</span><span class="o">.</span><span class="n">nu</span><span class="p">,</span>
                    <span class="n">ys</span><span class="o">=</span><span class="n">matInfo</span><span class="o">.</span><span class="n">St</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="n">matInfo</span><span class="o">.</span><span class="n">a</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="c1"># Nastran orthotropic material card</span>
            <span class="k">elif</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;MAT8&quot;</span><span class="p">:</span>
                <span class="n">E1</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">e11</span>
                <span class="n">E2</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">e22</span>
                <span class="n">nu12</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">nu12</span>
                <span class="n">G12</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">g12</span>
                <span class="n">G13</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">g1z</span>
                <span class="n">G23</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">g2z</span>
                <span class="c1"># If out-of-plane shear values are 0, Nastran defaults them to the in-plane</span>
                <span class="k">if</span> <span class="n">G13</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">G13</span> <span class="o">=</span> <span class="n">G12</span>
                <span class="k">if</span> <span class="n">G23</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">G23</span> <span class="o">=</span> <span class="n">G12</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">rho</span>
                <span class="n">Xt</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">Xt</span>
                <span class="n">Xc</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">Xc</span>
                <span class="n">Yt</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">Yt</span>
                <span class="n">Yc</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">Yc</span>
                <span class="n">S12</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">S</span>

                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">S12</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">Xt</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">Xc</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">Yt</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">Yc</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_TACSWarning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;MAT8 card </span><span class="si">{</span><span class="n">matInfo</span><span class="o">.</span><span class="n">mid</span><span class="si">}</span><span class="s2"> has a zero strength, check Xc, Xt, Yc, Yt, and S12.&quot;</span>
                        <span class="s2">&quot;Otherwise Tsai-Wu Failure criterion is undefined or infinity.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># TODO: add alpha</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">MaterialProperties</span><span class="p">(</span>
                    <span class="n">rho</span><span class="o">=</span><span class="n">rho</span><span class="p">,</span>
                    <span class="n">E1</span><span class="o">=</span><span class="n">E1</span><span class="p">,</span>
                    <span class="n">E2</span><span class="o">=</span><span class="n">E2</span><span class="p">,</span>
                    <span class="n">nu12</span><span class="o">=</span><span class="n">nu12</span><span class="p">,</span>
                    <span class="n">G12</span><span class="o">=</span><span class="n">G12</span><span class="p">,</span>
                    <span class="n">G13</span><span class="o">=</span><span class="n">G13</span><span class="p">,</span>
                    <span class="n">G23</span><span class="o">=</span><span class="n">G23</span><span class="p">,</span>
                    <span class="n">Xt</span><span class="o">=</span><span class="n">Xt</span><span class="p">,</span>
                    <span class="n">Xc</span><span class="o">=</span><span class="n">Xc</span><span class="p">,</span>
                    <span class="n">Yt</span><span class="o">=</span><span class="n">Yt</span><span class="p">,</span>
                    <span class="n">Yc</span><span class="o">=</span><span class="n">Yc</span><span class="p">,</span>
                    <span class="n">S12</span><span class="o">=</span><span class="n">S12</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="c1"># Nastran 2D anisotropic material card</span>
            <span class="k">elif</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;MAT2&quot;</span><span class="p">:</span>
                <span class="n">C11</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">G11</span>
                <span class="n">C12</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">G12</span>
                <span class="n">C22</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">G22</span>
                <span class="n">C13</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">G13</span>
                <span class="n">C23</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">G23</span>
                <span class="n">C33</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">G33</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="n">matInfo</span><span class="o">.</span><span class="n">rho</span>
                <span class="c1"># See if this card features anisotropic coupling terms (which we don&#39;t support yet)</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">C13</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">C11</span> <span class="o">+</span> <span class="n">C22</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">1e-8</span>
                    <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">C23</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">C11</span> <span class="o">+</span> <span class="n">C22</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">1e-8</span>
                <span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_TACSWarning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;MAT2 card </span><span class="si">{</span><span class="n">matInfo</span><span class="o">.</span><span class="n">mid</span><span class="si">}</span><span class="s2"> has anisotropic stiffness components that are not currently supported. &quot;</span>
                        <span class="s2">&quot;These terms will be dropped and the material treated as orthotropic. &quot;</span>
                        <span class="s2">&quot;Result accuracy may be affected.&quot;</span>
                    <span class="p">)</span>
                <span class="n">nu12</span> <span class="o">=</span> <span class="n">C12</span> <span class="o">/</span> <span class="n">C22</span>
                <span class="n">nu21</span> <span class="o">=</span> <span class="n">C12</span> <span class="o">/</span> <span class="n">C11</span>
                <span class="n">E1</span> <span class="o">=</span> <span class="n">C11</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">nu12</span> <span class="o">*</span> <span class="n">nu21</span><span class="p">)</span>
                <span class="n">E2</span> <span class="o">=</span> <span class="n">C22</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">nu12</span> <span class="o">*</span> <span class="n">nu21</span><span class="p">)</span>
                <span class="n">G12</span> <span class="o">=</span> <span class="n">G13</span> <span class="o">=</span> <span class="n">G23</span> <span class="o">=</span> <span class="n">C33</span>
                <span class="c1"># TODO: add alpha</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">MaterialProperties</span><span class="p">(</span>
                    <span class="n">rho</span><span class="o">=</span><span class="n">rho</span><span class="p">,</span> <span class="n">E1</span><span class="o">=</span><span class="n">E1</span><span class="p">,</span> <span class="n">E2</span><span class="o">=</span><span class="n">E2</span><span class="p">,</span> <span class="n">nu12</span><span class="o">=</span><span class="n">nu12</span><span class="p">,</span> <span class="n">G12</span><span class="o">=</span><span class="n">G12</span><span class="p">,</span> <span class="n">G13</span><span class="o">=</span><span class="n">G13</span><span class="p">,</span> <span class="n">G23</span><span class="o">=</span><span class="n">G23</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unsupported material type &#39;</span><span class="si">{</span><span class="n">matInfo</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&#39; for material number </span><span class="si">{</span><span class="n">matInfo</span><span class="o">.</span><span class="n">mid</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="n">mat</span>

        <span class="k">def</span> <span class="nf">elemCallBack</span><span class="p">(</span>
            <span class="n">dvNum</span><span class="p">,</span> <span class="n">compID</span><span class="p">,</span> <span class="n">compDescript</span><span class="p">,</span> <span class="n">elemDescripts</span><span class="p">,</span> <span class="n">globalDVs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">):</span>
            <span class="c1"># Initialize scale list for design variables we will add</span>
            <span class="n">scaleList</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Get the Nastran property ID</span>
            <span class="n">propertyID</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;propID&quot;</span><span class="p">]</span>
            <span class="n">propInfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">propertyID</span><span class="p">]</span>
            <span class="n">elemInfo</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># First we define the material object</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># This property only references one material</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">propInfo</span><span class="p">,</span> <span class="s2">&quot;mid_ref&quot;</span><span class="p">):</span>
                <span class="n">matInfo</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">mid_ref</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">matCallBack</span><span class="p">(</span><span class="n">matInfo</span><span class="p">)</span>
            <span class="c1"># This property references multiple materials (maybe a laminate)</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">propInfo</span><span class="p">,</span> <span class="s2">&quot;mids_ref&quot;</span><span class="p">):</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">matInfo</span> <span class="ow">in</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">mids_ref</span><span class="p">:</span>
                    <span class="n">mat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matCallBack</span><span class="p">(</span><span class="n">matInfo</span><span class="p">))</span>

            <span class="c1"># Next we define the constitutive object</span>
            <span class="k">if</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;PSHELL&quot;</span><span class="p">:</span>  <span class="c1"># Nastran isotropic shell</span>
                <span class="n">kcorr</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">tst</span>

                <span class="k">if</span> <span class="s2">&quot;T&quot;</span> <span class="ow">in</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">]:</span>
                    <span class="n">thickness</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xinit</span>
                    <span class="n">tNum</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">minThickness</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xlb</span>
                    <span class="n">maxThickness</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xub</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">scaleList</span><span class="p">[</span><span class="n">tNum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span>
                        <span class="mi">0</span>
                    <span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">thickness</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">t</span>
                    <span class="n">tNum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">minThickness</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="n">maxThickness</span> <span class="o">=</span> <span class="mf">1e20</span>

                <span class="n">con</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">IsoShellConstitutive</span><span class="p">(</span>
                    <span class="n">mat</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">thickness</span><span class="p">,</span> <span class="n">tlb</span><span class="o">=</span><span class="n">minThickness</span><span class="p">,</span> <span class="n">tub</span><span class="o">=</span><span class="n">maxThickness</span><span class="p">,</span> <span class="n">tNum</span><span class="o">=</span><span class="n">tNum</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;PCOMP&quot;</span><span class="p">:</span>  <span class="c1"># Nastran composite shell</span>
                <span class="n">numPlies</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">nplies</span>
                <span class="n">plyThicknesses</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">plyAngles</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">plyMats</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># if the laminate is symmetric, mirror the ply indices</span>
                <span class="k">if</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">lam</span> <span class="o">==</span> <span class="s2">&quot;SYM&quot;</span><span class="p">:</span>
                    <span class="n">plyIndices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">numPlies</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>
                    <span class="n">plyIndices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">plyIndices</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">plyIndices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">numPlies</span><span class="p">)</span>

                <span class="c1"># Loop through plies and setup each entry in layup</span>
                <span class="k">for</span> <span class="n">ply_i</span> <span class="ow">in</span> <span class="n">plyIndices</span><span class="p">:</span>
                    <span class="n">plyThicknesses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">propInfo</span><span class="o">.</span><span class="n">thicknesses</span><span class="p">[</span><span class="n">ply_i</span><span class="p">])</span>
                    <span class="n">plyMat</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">OrthotropicPly</span><span class="p">(</span>
                        <span class="n">plyThicknesses</span><span class="p">[</span><span class="n">ply_i</span><span class="p">],</span> <span class="n">mat</span><span class="p">[</span><span class="n">ply_i</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">plyMats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plyMat</span><span class="p">)</span>
                    <span class="n">plyAngles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">propInfo</span><span class="o">.</span><span class="n">thetas</span><span class="p">[</span><span class="n">ply_i</span><span class="p">]))</span>

                <span class="c1"># Convert thickness/angles to appropriate numpy array</span>
                <span class="n">plyThicknesses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">plyThicknesses</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">plyAngles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">plyAngles</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

                <span class="c1"># Get the total laminate thickness</span>
                <span class="n">lamThickness</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">Thickness</span><span class="p">()</span>
                <span class="c1"># Get the offset distance from the ref plane to the midplane</span>
                <span class="n">tOffset</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">propInfo</span><span class="o">.</span><span class="n">z0</span> <span class="o">/</span> <span class="n">lamThickness</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">lam</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">lam</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;SYM&quot;</span><span class="p">,</span> <span class="s2">&quot;MEM&quot;</span><span class="p">]:</span>
                    <span class="c1"># Discrete laminate class (not for optimization)</span>
                    <span class="n">con</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">CompositeShellConstitutive</span><span class="p">(</span>
                        <span class="n">plyMats</span><span class="p">,</span> <span class="n">plyThicknesses</span><span class="p">,</span> <span class="n">plyAngles</span><span class="p">,</span> <span class="n">tOffset</span><span class="o">=</span><span class="n">tOffset</span>
                    <span class="p">)</span>

                <span class="k">elif</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">lam</span> <span class="o">==</span> <span class="s2">&quot;SMEAR&quot;</span><span class="p">:</span>
                    <span class="n">plyFractions</span> <span class="o">=</span> <span class="n">plyThicknesses</span> <span class="o">/</span> <span class="n">lamThickness</span>
                    <span class="n">con</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">SmearedCompositeShellConstitutive</span><span class="p">(</span>
                        <span class="n">plyMats</span><span class="p">,</span> <span class="n">lamThickness</span><span class="p">,</span> <span class="n">plyAngles</span><span class="p">,</span> <span class="n">plyFractions</span><span class="p">,</span> <span class="n">t_offset</span><span class="o">=</span><span class="n">tOffset</span>
                    <span class="p">)</span>

                <span class="c1"># Need to add functionality to consider only membrane in TACS for type = MEM</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Unrecognized LAM type &#39;</span><span class="si">{</span><span class="n">propInfo</span><span class="o">.</span><span class="n">lam</span><span class="si">}</span><span class="s2">&#39; for PCOMP number </span><span class="si">{</span><span class="n">propertyID</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>

            <span class="k">elif</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;PSOLID&quot;</span><span class="p">:</span>  <span class="c1"># Nastran solid property</span>
                <span class="k">if</span> <span class="s2">&quot;T&quot;</span> <span class="ow">in</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">]:</span>
                    <span class="n">thickness</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xinit</span>
                    <span class="n">tNum</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">minThickness</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xlb</span>
                    <span class="n">maxThickness</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xub</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dvids_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">scaleList</span><span class="p">[</span><span class="n">tNum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;dvs&quot;</span><span class="p">][</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span>
                        <span class="mi">0</span>
                    <span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">thickness</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="n">tNum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">minThickness</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="n">maxThickness</span> <span class="o">=</span> <span class="mf">10.0</span>

                <span class="n">con</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">SolidConstitutive</span><span class="p">(</span>
                    <span class="n">mat</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">thickness</span><span class="p">,</span> <span class="n">tlb</span><span class="o">=</span><span class="n">minThickness</span><span class="p">,</span> <span class="n">tub</span><span class="o">=</span><span class="n">maxThickness</span><span class="p">,</span> <span class="n">tNum</span><span class="o">=</span><span class="n">tNum</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;PBUSH&quot;</span><span class="p">:</span>  <span class="c1"># Nastran spring</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">Ki</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="n">k</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">Ki</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">con</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">DOFSpringConstitutive</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;PBAR&quot;</span><span class="p">:</span>  <span class="c1"># Nastran bar</span>
                <span class="n">area</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">A</span>
                <span class="n">I1</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">i1</span>
                <span class="n">I2</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">i2</span>
                <span class="c1"># Nastran uses negative convention for POI&#39;s</span>
                <span class="n">I12</span> <span class="o">=</span> <span class="o">-</span><span class="n">propInfo</span><span class="o">.</span><span class="n">i12</span>
                <span class="n">J</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">j</span>
                <span class="n">k1</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">k1</span>
                <span class="n">k2</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">k2</span>

                <span class="c1"># pynastran defaults these values to 1e8,</span>
                <span class="c1"># which can lead to scaling issues in the stiffness matrix</span>
                <span class="c1"># We truncate this value to 1e3 to prevent this</span>
                <span class="k">if</span> <span class="n">k1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">k1</span> <span class="o">&gt;</span> <span class="mf">1e3</span><span class="p">:</span>
                    <span class="n">k1</span> <span class="o">=</span> <span class="mf">1e3</span>

                <span class="k">if</span> <span class="n">k2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">k2</span> <span class="o">&gt;</span> <span class="mf">1e3</span><span class="p">:</span>
                    <span class="n">k2</span> <span class="o">=</span> <span class="mf">1e3</span>

                <span class="n">con</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">BasicBeamConstitutive</span><span class="p">(</span>
                    <span class="n">mat</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">area</span><span class="p">,</span> <span class="n">Iy</span><span class="o">=</span><span class="n">I2</span><span class="p">,</span> <span class="n">Iz</span><span class="o">=</span><span class="n">I1</span><span class="p">,</span> <span class="n">Iyz</span><span class="o">=</span><span class="n">I12</span><span class="p">,</span> <span class="n">J</span><span class="o">=</span><span class="n">J</span><span class="p">,</span> <span class="n">ky</span><span class="o">=</span><span class="n">k1</span><span class="p">,</span> <span class="n">kz</span><span class="o">=</span><span class="n">k2</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;PROD&quot;</span><span class="p">:</span>  <span class="c1"># Nastran rod</span>
                <span class="n">area</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">A</span>
                <span class="n">J</span> <span class="o">=</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">j</span>
                <span class="n">k1</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">k2</span> <span class="o">=</span> <span class="mf">0.0</span>

                <span class="n">con</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">BasicBeamConstitutive</span><span class="p">(</span>
                    <span class="n">mat</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">area</span><span class="p">,</span> <span class="n">J</span><span class="o">=</span><span class="n">J</span><span class="p">,</span> <span class="n">ky</span><span class="o">=</span><span class="n">k1</span><span class="p">,</span> <span class="n">kz</span><span class="o">=</span><span class="n">k2</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unsupported property type &#39;</span><span class="si">{</span><span class="n">propInfo</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&#39; for property number </span><span class="si">{</span><span class="n">propertyID</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="p">)</span>

            <span class="c1"># Set up transform object which may be required for certain elements</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;PSHELL&quot;</span><span class="p">,</span> <span class="s2">&quot;PCOMP&quot;</span><span class="p">]:</span>
                <span class="n">mcid</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">theta_mcid_ref</span>
                <span class="k">if</span> <span class="n">mcid</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">mcid</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;CORD2R&quot;</span><span class="p">:</span>
                        <span class="n">refAxis</span> <span class="o">=</span> <span class="n">mcid</span><span class="o">.</span><span class="n">i</span>
                        <span class="n">transform</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">ShellRefAxisTransform</span><span class="p">(</span><span class="n">refAxis</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Don&#39;t support spherical/cylindrical yet</span>
                        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                            <span class="s2">&quot;Unsupported material coordinate system type &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">mcid</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&#39; for property number </span><span class="si">{</span><span class="n">propertyID</span><span class="si">}</span><span class="s2">.&quot;</span>
                        <span class="p">)</span>
            <span class="k">elif</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;PBAR&quot;</span><span class="p">]:</span>
                <span class="n">refAxis</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">g0_vector</span>
                <span class="n">transform</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">BeamRefAxisTransform</span><span class="p">(</span><span class="n">refAxis</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;PROD&quot;</span><span class="p">:</span>
                <span class="n">refAxis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
                <span class="p">)</span>  <span class="c1"># dummy ref_axis, not really needed for rods</span>
                <span class="n">transform</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">BeamRefAxisTransform</span><span class="p">(</span><span class="n">refAxis</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">propInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;PBUSH&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cid_ref</span><span class="p">:</span>
                    <span class="n">refAxis_i</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cid_ref</span><span class="o">.</span><span class="n">i</span>
                    <span class="n">refAxis_j</span> <span class="o">=</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cid_ref</span><span class="o">.</span><span class="n">j</span>
                    <span class="n">transform</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">SpringRefFrameTransform</span><span class="p">(</span>
                        <span class="n">refAxis_i</span><span class="p">,</span> <span class="n">refAxis_j</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">refAxis</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                        <span class="o">-</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="o">.</span><span class="n">nodes_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="o">.</span><span class="n">get_position</span><span class="p">()</span>
                    <span class="p">)</span>
                    <span class="n">transform</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">SpringRefAxisTransform</span><span class="p">(</span><span class="n">refAxis</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">g0_ref</span><span class="p">:</span>
                    <span class="n">refAxis</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">g0_ref</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span>
                        <span class="o">-</span> <span class="n">elemDict</span><span class="p">[</span><span class="n">propertyID</span><span class="p">][</span><span class="s2">&quot;elements&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="o">.</span><span class="n">nodes_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="o">.</span><span class="n">get_position</span><span class="p">()</span>
                    <span class="p">)</span>
                    <span class="n">transform</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">SpringRefAxisTransform</span><span class="p">(</span><span class="n">refAxis</span><span class="p">)</span>

            <span class="c1"># Finally set up the element objects belonging to this component</span>
            <span class="n">elemList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">descript</span> <span class="ow">in</span> <span class="n">elemDescripts</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">descript</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CQUAD4&quot;</span><span class="p">,</span> <span class="s2">&quot;CQUADR&quot;</span><span class="p">]:</span>
                    <span class="n">elem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">Quad4Shell</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">con</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">descript</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CQUAD9&quot;</span><span class="p">,</span> <span class="s2">&quot;CQUAD&quot;</span><span class="p">]:</span>
                    <span class="n">elem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">Quad9Shell</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">con</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">descript</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CTRIA3&quot;</span><span class="p">,</span> <span class="s2">&quot;CTRIAR&quot;</span><span class="p">]:</span>
                    <span class="n">elem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">Tri3Shell</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">con</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">descript</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CBAR&quot;</span><span class="p">,</span> <span class="s2">&quot;CROD&quot;</span><span class="p">]:</span>
                    <span class="n">elem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">Beam2</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">con</span><span class="p">)</span>
                <span class="k">elif</span> <span class="s2">&quot;CTETRA&quot;</span> <span class="ow">in</span> <span class="n">descript</span><span class="p">:</span>
                    <span class="c1"># May have variable number of nodes in card</span>
                    <span class="n">nnodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">elemInfo</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">nnodes</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                        <span class="n">basis</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">LinearTetrahedralBasis</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="n">nnodes</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                        <span class="n">basis</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">QuadraticTetrahedralBasis</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;TACS does not currently support CTETRA elements with </span><span class="si">{</span><span class="n">nnodes</span><span class="si">}</span><span class="s2"> nodes.&quot;</span>
                        <span class="p">)</span>
                    <span class="n">model</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">LinearElasticity3D</span><span class="p">(</span><span class="n">con</span><span class="p">)</span>
                    <span class="n">elem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">Element3D</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">basis</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">descript</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CHEXA8&quot;</span><span class="p">,</span> <span class="s2">&quot;CHEXA&quot;</span><span class="p">]:</span>
                    <span class="n">basis</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">LinearHexaBasis</span><span class="p">()</span>
                    <span class="n">model</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">LinearElasticity3D</span><span class="p">(</span><span class="n">con</span><span class="p">)</span>
                    <span class="n">elem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">Element3D</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">basis</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">descript</span> <span class="o">==</span> <span class="s2">&quot;CBUSH&quot;</span><span class="p">:</span>
                    <span class="n">elem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">SpringElement</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">con</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                        <span class="s2">&quot;Unsupported element type &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">descript</span><span class="si">}</span><span class="s2">&#39; specified for property number </span><span class="si">{</span><span class="n">propertyID</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
                <span class="n">elemList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">elemList</span><span class="p">,</span> <span class="n">scaleList</span>

        <span class="k">return</span> <span class="n">elemCallBack</span>

<div class="viewcode-block" id="pyTACS.getOrigDesignVars">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getOrigDesignVars">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">getOrigDesignVars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get the original design variables that were specified with</span>
<span class="sd">        during assembler creation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x : numpy.ndarray</span>
<span class="sd">            The original design variable vector set in tacs.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="pyTACS.getDesignVarRange">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getDesignVarRange">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">getDesignVarRange</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get the lower/upper bounds for the design variables.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xlb : numpy.ndarray</span>
<span class="sd">            The design variable lower bound.</span>
<span class="sd">        xub : numpy.ndarray</span>
<span class="sd">            The design variable upper bound.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xlb</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">xub</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="pyTACS.createDesignVec">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.createDesignVec">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">createDesignVec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">asBVec</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new tacs distributed design vector.</span>
<span class="sd">        Values are initialized to zero.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        asBVec : bool</span>
<span class="sd">            Flag that determines whether to return</span>
<span class="sd">            design vector as tacs :class:`~TACS.Vec` (True) or numpy array (False).</span>
<span class="sd">            Defaults to False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x : numpy.ndarray or tacs.TACS.Vec</span>
<span class="sd">            Distributed design variable vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xVec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createDesignVec</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">asBVec</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xVec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xVec</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span></div>


<div class="viewcode-block" id="pyTACS.getNumDesignVars">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getNumDesignVars">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">getNumDesignVars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of design variables on this processor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndvs : int</span>
<span class="sd">            Number of design variables on this processor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="o">.</span><span class="n">getSize</span><span class="p">()</span></div>


<div class="viewcode-block" id="pyTACS.getTotalNumDesignVars">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getTotalNumDesignVars">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">getTotalNumDesignVars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of design variables across all processors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndvs : int</span>
<span class="sd">            Total number of design variables across all processors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span></div>


<div class="viewcode-block" id="pyTACS.getOrigNodes">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getOrigNodes">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">getOrigNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the original mesh coordinates read in from the meshLoader.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coords : numpy.ndarray</span>
<span class="sd">            Structural coordinate in array of size (N * 3) where N is</span>
<span class="sd">            the number of structural nodes on this processor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xpts0</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="pyTACS.createNodeVec">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.createNodeVec">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">createNodeVec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">asBVec</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new tacs distributed node vector.</span>
<span class="sd">        Values are initialized to zero.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        asBVec : bool</span>
<span class="sd">            Flag that determines whether to return</span>
<span class="sd">            node vector as tacs :class:`~TACS.Vec` (True) or numpy array (False).</span>
<span class="sd">            Defaults to False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xpts : numpy.ndarray or tacs.TACS.Vec</span>
<span class="sd">            Distributed node coordinate vector</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">xptVec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createNodeVec</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">asBVec</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xptVec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xptVec</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span></div>


<div class="viewcode-block" id="pyTACS.getNumOwnedNodes">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getNumOwnedNodes">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">getNumOwnedNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of nodes owned by this processor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nNodes : int</span>
<span class="sd">            Number of nodes owned by this proc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">getNumOwnedNodes</span><span class="p">()</span></div>


<div class="viewcode-block" id="pyTACS.getNumOwnedMultiplierNodes">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getNumOwnedMultiplierNodes">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">getNumOwnedMultiplierNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of lagrange multiplier nodes owned by this processor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nMultNodes : int</span>
<span class="sd">            Number of multiplier nodes owned by this proc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getLocalMultiplierNodeIDs</span><span class="p">())</span></div>


<div class="viewcode-block" id="pyTACS.getLocalMultiplierNodeIDs">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getLocalMultiplierNodeIDs">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">getLocalMultiplierNodeIDs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the tacs indices of multiplier nodes used to hold lagrange multipliers on this processor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nodeIDs : list[int]</span>
<span class="sd">            List of multiplier node ID&#39;s owned by this proc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getLocalMultiplierNodeIDs</span><span class="p">()</span></div>


<div class="viewcode-block" id="pyTACS.createVec">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.createVec">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">createVec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">asBVec</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new tacs distributed state variable vector.</span>
<span class="sd">        Values are initialized to zero.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        asBVec : bool</span>
<span class="sd">            Flag that determines whether to return</span>
<span class="sd">            state vector as tacs :class:`~TACS.Vec` (True) or numpy array (False).</span>
<span class="sd">            Defaults to False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vars : numpy.ndarray or tacs.TACS.Vec</span>
<span class="sd">            Distributed state variable vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createVec</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">asBVec</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">vars</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">vars</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span></div>


<div class="viewcode-block" id="pyTACS.getVarsPerNode">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getVarsPerNode">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">getVarsPerNode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of variables per node for the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vpn : int</span>
<span class="sd">            Number of variables per node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">getVarsPerNode</span><span class="p">()</span></div>


<div class="viewcode-block" id="pyTACS.applyBCsToVec">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.applyBCsToVec">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">applyBCsToVec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies zeros to boundary condition DOFs in input vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vec : numpy.ndarray or tacs.TACS.Vec</span>
<span class="sd">            Vector to apply boundary conditions to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if input is a BVec or numpy array</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">Vec</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">applyBCs</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">vec</span>
            <span class="c1"># Create temporary BVec</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createVec</span><span class="p">()</span>
            <span class="c1"># Copy array values to BVec</span>
            <span class="n">vec</span><span class="o">.</span><span class="n">getArray</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">array</span>
            <span class="c1"># Apply BCs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">applyBCs</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
            <span class="c1"># Copy values back to array</span>
            <span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span></div>


<div class="viewcode-block" id="pyTACS.setBCsInVec">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.setBCsInVec">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">setBCsInVec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets dirichlet boundary condition values in the input vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vec : numpy.ndarray or tacs.TACS.Vec</span>
<span class="sd">            Vector to set boundary conditions in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if input is a BVec or numpy array</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">Vec</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">setBCs</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">vec</span>
            <span class="c1"># Create temporary BVec</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">createVec</span><span class="p">()</span>
            <span class="c1"># Copy array values to BVec</span>
            <span class="n">vec</span><span class="o">.</span><span class="n">getArray</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">array</span>
            <span class="c1"># Apply BCs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">setBCs</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
            <span class="c1"># Copy values back to array</span>
            <span class="n">array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">getArray</span><span class="p">()</span></div>


<div class="viewcode-block" id="pyTACS.createStaticProblem">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.createStaticProblem">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">createStaticProblem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new staticProblem for modeling a static load cases.</span>
<span class="sd">        This object can be used to set loads, evalFunctions as well as perform</span>
<span class="sd">        solutions and sensitivities related to static problems</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name to assign problem.</span>
<span class="sd">        options : dict</span>
<span class="sd">            Problem-specific options to pass to StaticProblem instance (case-insensitive).</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        problem : tacs.problems.StaticProblem</span>
<span class="sd">            StaticProblem object used for modeling and solving static cases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">problem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">problems</span><span class="o">.</span><span class="n">static</span><span class="o">.</span><span class="n">StaticProblem</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputViewer</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">isNonlinear</span><span class="p">,</span>
            <span class="n">options</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Set with original design vars and coordinates, in case they have changed</span>
        <span class="n">problem</span><span class="o">.</span><span class="n">setDesignVars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">problem</span><span class="o">.</span><span class="n">setNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xpts0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">problem</span></div>


<div class="viewcode-block" id="pyTACS.createTransientProblem">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.createTransientProblem">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">createTransientProblem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">tInit</span><span class="p">,</span> <span class="n">tFinal</span><span class="p">,</span> <span class="n">numSteps</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new TransientProblem for modeling a transient load cases.</span>
<span class="sd">        This object can be used to set loads, evalFunctions as well as perform</span>
<span class="sd">        solutions and sensitivities related to transient problems</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name to assign problem.</span>
<span class="sd">        tInit : float</span>
<span class="sd">            Starting time for transient time integration</span>
<span class="sd">        tFinal : float</span>
<span class="sd">            Ending time for transient time integration</span>
<span class="sd">        numSteps : int</span>
<span class="sd">            Number of time steps for transient time integration</span>
<span class="sd">        options : dict</span>
<span class="sd">            Problem-specific options to pass to TransientProblem instance (case-insensitive).</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        problem : tacs.problems.TransientProblem</span>
<span class="sd">            TransientProblem object used for modeling and solving transient cases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">problem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">problems</span><span class="o">.</span><span class="n">transient</span><span class="o">.</span><span class="n">TransientProblem</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">tInit</span><span class="p">,</span>
            <span class="n">tFinal</span><span class="p">,</span>
            <span class="n">numSteps</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputViewer</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">isNonlinear</span><span class="p">,</span>
            <span class="n">options</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Set with original design vars and coordinates, in case they have changed</span>
        <span class="n">problem</span><span class="o">.</span><span class="n">setDesignVars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">problem</span><span class="o">.</span><span class="n">setNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xpts0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">problem</span></div>


<div class="viewcode-block" id="pyTACS.createModalProblem">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.createModalProblem">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">createModalProblem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">numEigs</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new ModalProblem for performing modal analysis.</span>
<span class="sd">        This problem can be used to identify the natural frequencies and mode</span>
<span class="sd">        shapes of the model through eigenvalue analysis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name to assign problem.</span>
<span class="sd">        sigma : float</span>
<span class="sd">            Guess for the lowest eigenvalue.</span>
<span class="sd">            This corresponds to the lowest expected frequency squared. (rad^2/s^2)</span>
<span class="sd">        numEigs : int</span>
<span class="sd">            Number of eigenvalues to solve for.</span>
<span class="sd">        options : dict</span>
<span class="sd">            Problem-specific options to pass to ModalProblem instance (case-insensitive).</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        problem : tacs.problems.ModalProblem</span>
<span class="sd">            ModalProblem object used for performing modal eigenvalue analysis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">problem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">problems</span><span class="o">.</span><span class="n">modal</span><span class="o">.</span><span class="n">ModalProblem</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">sigma</span><span class="p">,</span>
            <span class="n">numEigs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputViewer</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">isNonlinear</span><span class="p">,</span>
            <span class="n">options</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Set with original design vars and coordinates, in case they have changed</span>
        <span class="n">problem</span><span class="o">.</span><span class="n">setDesignVars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">problem</span><span class="o">.</span><span class="n">setNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xpts0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">problem</span></div>


<div class="viewcode-block" id="pyTACS.createBucklingProblem">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.createBucklingProblem">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">createBucklingProblem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">numEigs</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new BucklingProblem for performing linearized buckling analysis.</span>
<span class="sd">        This problem can be used to identify the buckling load factors and mode</span>
<span class="sd">        shapes of the model through eigenvalue analysis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name to assign problem.</span>
<span class="sd">        sigma : float</span>
<span class="sd">            Guess for the lowest eigenvalue.</span>
<span class="sd">            This corresponds to the lowest expected buckling load factor.</span>
<span class="sd">        numEigs : int</span>
<span class="sd">            Number of eigenvalues to solve for.</span>
<span class="sd">        options : dict</span>
<span class="sd">            Problem-specific options to pass to ModalProblem instance (case-insensitive).</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        problem : tacs.problems.BucklingProblem</span>
<span class="sd">            BucklingProblem object used for performing buckling eigenvalue analysis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">problem</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">problems</span><span class="o">.</span><span class="n">buckling</span><span class="o">.</span><span class="n">BucklingProblem</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">sigma</span><span class="p">,</span>
            <span class="n">numEigs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputViewer</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">isNonlinear</span><span class="p">,</span>
            <span class="n">options</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Set with original design vars and coordinates, in case they have changed</span>
        <span class="n">problem</span><span class="o">.</span><span class="n">setDesignVars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">problem</span><span class="o">.</span><span class="n">setNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xpts0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">problem</span></div>


<div class="viewcode-block" id="pyTACS.createTACSProbsFromBDF">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.createTACSProbsFromBDF">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">createTACSProbsFromBDF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automatically define tacs problem classes with loads using information contained in BDF file.</span>
<span class="sd">        This function assumes all loads are specified in the BDF and allows users to</span>
<span class="sd">        skip setting loads in Python.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        structProblems : dict[int, tacs.problems.TACSProblem]</span>
<span class="sd">            Dictionary containing a predefined TACSProblem for every loadcase found in the BDF.</span>
<span class="sd">            The dictionary keys are the loadcase IDs from the BDF.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Currently only supports LOAD, FORCE, MOMENT, GRAV, RFORCE, PLOAD2, PLOAD4, TLOAD1, TLOAD2, and DLOAD cards.</span>
<span class="sd">        Currently only supports staticProblem (SOL 101), transientProblem (SOL 109), and modalProblems (SOL 103)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure cross-referencing is turned on in pynastran</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">is_xrefed</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">cross_reference</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">is_xrefed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">structProblems</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># If subcases have been added in Nastran, then subCase 0 should not be run</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">subcases</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">skipCaseZero</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">skipCaseZero</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Loop through every load set and create a corresponding structural problem</span>
        <span class="k">for</span> <span class="n">subCase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">subcases</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">skipCaseZero</span> <span class="ow">and</span> <span class="n">subCase</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="s2">&quot;SUBTITLE&quot;</span> <span class="ow">in</span> <span class="n">subCase</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">subCase</span><span class="p">[</span><span class="s2">&quot;SUBTITLE&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;load_set_</span><span class="si">%.3d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">subCase</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">sol</span> <span class="o">==</span> <span class="mi">103</span><span class="p">:</span>
                <span class="n">methodID</span> <span class="o">=</span> <span class="n">subCase</span><span class="p">[</span><span class="s2">&quot;METHOD&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">methodInfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">methods</span><span class="p">[</span><span class="n">methodID</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">methodInfo</span><span class="o">.</span><span class="n">v1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sigma</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">methodInfo</span><span class="o">.</span><span class="n">v1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="k">elif</span> <span class="n">methodInfo</span><span class="o">.</span><span class="n">v2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sigma</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">methodInfo</span><span class="o">.</span><span class="n">v2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sigma</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="k">if</span> <span class="n">methodInfo</span><span class="o">.</span><span class="n">nd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">nEigs</span> <span class="o">=</span> <span class="n">methodInfo</span><span class="o">.</span><span class="n">nd</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nEigs</span> <span class="o">=</span> <span class="mi">20</span>
                <span class="n">problem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createModalProblem</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">nEigs</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">sol</span> <span class="o">==</span> <span class="mi">109</span><span class="p">:</span>
                <span class="c1"># Get time step info</span>
                <span class="k">if</span> <span class="s2">&quot;TSTEP&quot;</span> <span class="ow">in</span> <span class="n">subCase</span><span class="p">:</span>
                    <span class="n">tStepID</span> <span class="o">=</span> <span class="n">subCase</span><span class="p">[</span><span class="s2">&quot;TSTEP&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">tStep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">tsteps</span><span class="p">[</span><span class="n">tStepID</span><span class="p">]</span>
                    <span class="n">nSteps</span> <span class="o">=</span> <span class="n">tStep</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">dt</span> <span class="o">=</span> <span class="n">tStep</span><span class="o">.</span><span class="n">DT</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># If no time step info was included, we&#39;ll skip this case</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_TACSWarning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;No TSTEP entry found in control deck for subcase number </span><span class="si">{</span><span class="n">subCase</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="s2">&quot;skipping case.&quot;</span>
                    <span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">problem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createTransientProblem</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">tInit</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">tFinal</span><span class="o">=</span><span class="n">dt</span> <span class="o">*</span> <span class="n">nSteps</span><span class="p">,</span> <span class="n">numSteps</span><span class="o">=</span><span class="n">nSteps</span>
                <span class="p">)</span>

                <span class="c1"># Find dynamic load specified for this subcase</span>
                <span class="k">if</span> <span class="s2">&quot;DLOAD&quot;</span> <span class="ow">in</span> <span class="n">subCase</span><span class="p">:</span>
                    <span class="n">dloadsID</span> <span class="o">=</span> <span class="n">subCase</span><span class="p">[</span><span class="s2">&quot;DLOAD&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">dloadSet</span><span class="p">,</span> <span class="n">dloadScale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">get_reduced_dloads</span><span class="p">(</span><span class="n">dloadsID</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">dloadInfo</span><span class="p">,</span> <span class="n">dscale</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dloadSet</span><span class="p">,</span> <span class="n">dloadScale</span><span class="p">):</span>
                        <span class="n">timeSteps</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">getTimeSteps</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">dloadInfo</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;TLOAD1&quot;</span><span class="p">,</span> <span class="s2">&quot;TLOAD2&quot;</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">dloadInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;TLOAD1&quot;</span><span class="p">:</span>
                                <span class="n">loadScales</span> <span class="o">=</span> <span class="n">dloadInfo</span><span class="o">.</span><span class="n">get_load_at_time</span><span class="p">(</span>
                                    <span class="n">timeSteps</span><span class="p">,</span> <span class="n">dscale</span>
                                <span class="p">)</span>
                            <span class="k">elif</span> <span class="n">dloadInfo</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;TLOAD2&quot;</span><span class="p">:</span>
                                <span class="n">loadScales</span> <span class="o">=</span> <span class="n">dloadInfo</span><span class="o">.</span><span class="n">get_load_at_time</span><span class="p">(</span>
                                    <span class="n">timeSteps</span><span class="p">,</span> <span class="n">dscale</span>
                                <span class="p">)</span>
                            <span class="k">if</span> <span class="n">dloadInfo</span><span class="o">.</span><span class="n">Type</span> <span class="o">!=</span> <span class="s2">&quot;LOAD&quot;</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_TACSWarning</span><span class="p">(</span>
                                    <span class="s2">&quot;Only &#39;LOAD&#39; types are supported for &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">dloadInfo</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&#39; card, but &#39;</span><span class="si">{</span><span class="n">dloadInfo</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&#39; </span><span class="si">{</span><span class="n">dloadInfo</span><span class="o">.</span><span class="n">sid</span><span class="si">}</span><span class="s2">, &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;was specified as </span><span class="si">{</span><span class="n">dloadInfo</span><span class="o">.</span><span class="n">Type</span><span class="si">}</span><span class="s2"> type&quot;</span>
                                <span class="p">)</span>
                            <span class="n">loadsID</span> <span class="o">=</span> <span class="n">dloadInfo</span><span class="o">.</span><span class="n">excite_id</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_TACSWarning</span><span class="p">(</span>
                                <span class="s2">&quot;Unsupported dload type &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">dloadInfo</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&#39; specified for load set number </span><span class="si">{</span><span class="n">dloadInfo</span><span class="o">.</span><span class="n">sid</span><span class="si">}</span><span class="s2">,&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot; skipping load&quot;</span>
                            <span class="p">)</span>
                            <span class="k">continue</span>
                        <span class="c1"># Loop through each time step and add loads to problem</span>
                        <span class="k">for</span> <span class="n">timeIndex</span><span class="p">,</span> <span class="n">scale</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">loadScales</span><span class="p">):</span>
                            <span class="n">problem</span><span class="o">.</span><span class="n">addLoadFromBDF</span><span class="p">(</span><span class="n">timeIndex</span><span class="p">,</span> <span class="n">loadsID</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">problem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createStaticProblem</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

                <span class="c1"># Find the static load specified for this test case</span>
                <span class="k">if</span> <span class="s2">&quot;LOAD&quot;</span> <span class="ow">in</span> <span class="n">subCase</span><span class="p">:</span>
                    <span class="c1"># Add loads to problem</span>
                    <span class="n">loadsID</span> <span class="o">=</span> <span class="n">subCase</span><span class="p">[</span><span class="s2">&quot;LOAD&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">problem</span><span class="o">.</span><span class="n">addLoadFromBDF</span><span class="p">(</span><span class="n">loadsID</span><span class="p">)</span>

            <span class="c1"># append to list of structural problems</span>
            <span class="n">structProblems</span><span class="p">[</span><span class="n">subCase</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">problem</span>

        <span class="k">return</span> <span class="n">structProblems</span></div>


<div class="viewcode-block" id="pyTACS.writeBDF">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.writeBDF">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">writeBDF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="p">,</span> <span class="n">problems</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write NASTRAN BDF file from problem class.</span>
<span class="sd">        Assumes all supplied Problems share the same nodal and design variable values.</span>

<span class="sd">        NOTE: Only supports writing loads from StaticProblem types.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fileName: str</span>
<span class="sd">            Name of file to write BDF file to.</span>
<span class="sd">        problems: tacs.problems.TACSProblem or list[tacs.problems.TACSProblem]</span>
<span class="sd">            List of pytacs Problem classes to write BDF file from.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure problems is in a list</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">problems</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">problems</span> <span class="o">=</span> <span class="p">[</span><span class="n">problems</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">problems</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">problems</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">problems</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">problems</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">problems</span><span class="p">)</span>

        <span class="c1"># Check that each problem was created by this pyTACS instance</span>
        <span class="k">for</span> <span class="n">problem</span> <span class="ow">in</span> <span class="n">problems</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">problem</span><span class="o">.</span><span class="n">assembler</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;This problem instance (</span><span class="si">{</span><span class="n">problem</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">) is not associated with this instance of pyTACS.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Make sure design variables are up-to-date</span>
        <span class="n">dv_bvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createDesignVec</span><span class="p">(</span><span class="n">asBVec</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">dv_bvec</span><span class="o">.</span><span class="n">getArray</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">problems</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getDesignVars</span><span class="p">()</span>
        <span class="c1"># Transfer all non-local dvs</span>
        <span class="n">dv_bvec</span><span class="o">.</span><span class="n">beginDistributeValues</span><span class="p">()</span>
        <span class="n">dv_bvec</span><span class="o">.</span><span class="n">endDistributeValues</span><span class="p">()</span>

        <span class="c1"># Get local node info for each processor</span>
        <span class="n">multNodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLocalMultiplierNodeIDs</span><span class="p">()</span>
        <span class="n">globalToLocalNodeIDDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getGlobalToLocalNodeIDDict</span><span class="p">()</span>
        <span class="n">Xpts_bvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">problems</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getNodes</span><span class="p">())</span>

        <span class="c1"># Gather local info to root processor</span>
        <span class="n">allMultNodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">multNodes</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">allGlobalToLocalNodeIDDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">globalToLocalNodeIDDict</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">allXpts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">Xpts_bvec</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Assemble new BDF file for mesh on root</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">newBDFInfo</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">bdf</span><span class="o">.</span><span class="n">BDF</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Write out updated node locations</span>
            <span class="n">nastranNodeIDs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">node_ids</span><span class="p">)</span>
            <span class="c1"># Loop through each proc and pull out new node locations</span>
            <span class="k">for</span> <span class="n">proc_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">xyz</span> <span class="o">=</span> <span class="n">allXpts</span><span class="p">[</span><span class="n">proc_i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">tacsGNodeID</span> <span class="ow">in</span> <span class="n">allGlobalToLocalNodeIDDict</span><span class="p">[</span><span class="n">proc_i</span><span class="p">]:</span>
                    <span class="c1"># Get local node ID</span>
                    <span class="n">tacsLNodeID</span> <span class="o">=</span> <span class="n">allGlobalToLocalNodeIDDict</span><span class="p">[</span><span class="n">proc_i</span><span class="p">][</span><span class="n">tacsGNodeID</span><span class="p">]</span>
                    <span class="c1"># Get Global nastran ID</span>
                    <span class="n">nastranGNodeID</span> <span class="o">=</span> <span class="n">nastranNodeIDs</span><span class="p">[</span><span class="n">tacsGNodeID</span><span class="p">]</span>
                    <span class="c1"># Add node to bdf file (if its not a multiplier node)</span>
                    <span class="k">if</span> <span class="n">tacsLNodeID</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allMultNodes</span><span class="p">[</span><span class="n">proc_i</span><span class="p">]:</span>
                        <span class="n">newBDFInfo</span><span class="o">.</span><span class="n">add_grid</span><span class="p">(</span><span class="n">nastranGNodeID</span><span class="p">,</span> <span class="n">xyz</span><span class="p">[</span><span class="n">tacsLNodeID</span><span class="p">])</span>

            <span class="c1"># Copy over boundary conditions</span>
            <span class="c1"># Set all con IDs to one</span>
            <span class="n">newBDFInfo</span><span class="o">.</span><span class="n">spcs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">spcID</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">spcs</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">spcCard</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">spcs</span><span class="p">[</span><span class="n">spcID</span><span class="p">]:</span>
                    <span class="n">newCard</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">spcCard</span><span class="p">)</span>
                    <span class="n">newCard</span><span class="o">.</span><span class="n">conid</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">newBDFInfo</span><span class="o">.</span><span class="n">spcs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newCard</span><span class="p">)</span>

            <span class="c1"># Write updated properties and elements</span>
            <span class="n">transObjs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">matObjs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">conObjs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">compID</span><span class="p">,</span> <span class="n">propID</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">properties</span><span class="p">):</span>
                <span class="c1"># Get TACS element object</span>
                <span class="n">elemObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getElementObject</span><span class="p">(</span><span class="n">compID</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="c1"># get dv nums for element</span>
                <span class="n">dvNums</span> <span class="o">=</span> <span class="n">elemObj</span><span class="o">.</span><span class="n">getDesignVarNums</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># Update design variable values</span>
                <span class="n">dvVals</span> <span class="o">=</span> <span class="n">dv_bvec</span><span class="o">.</span><span class="n">getValues</span><span class="p">(</span><span class="n">dvNums</span><span class="p">)</span>
                <span class="n">elemObj</span><span class="o">.</span><span class="n">setDesignVars</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dvVals</span><span class="p">)</span>
                <span class="c1"># Get TACS constitutive object for element (if applicable)</span>
                <span class="n">conObj</span> <span class="o">=</span> <span class="n">elemObj</span><span class="o">.</span><span class="n">getConstitutive</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">conObj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Set the property ID number for the class to be used in the Nastran card</span>
                    <span class="n">conObj</span><span class="o">.</span><span class="n">setNastranID</span><span class="p">(</span><span class="n">propID</span><span class="p">)</span>
                    <span class="n">conObjs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conObj</span><span class="p">)</span>
                    <span class="c1"># Get TACS material properties object for constitutive (if applicable)</span>
                    <span class="n">matObj</span> <span class="o">=</span> <span class="n">conObj</span><span class="o">.</span><span class="n">getMaterialProperties</span><span class="p">()</span>
                    <span class="c1"># May be a single object...</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">matObj</span><span class="p">,</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constitutive</span><span class="o">.</span><span class="n">MaterialProperties</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">matObj</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">matObjs</span><span class="p">:</span>
                            <span class="n">matObjs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matObj</span><span class="p">)</span>
                    <span class="c1"># or a list (plys for composite classes)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">matObj</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">mat_i</span> <span class="ow">in</span> <span class="n">matObj</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">mat_i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">matObjs</span><span class="p">:</span>
                                <span class="n">matObjs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mat_i</span><span class="p">)</span>
                <span class="c1"># Get TACS transform object for element (if applicable)</span>
                <span class="n">transObj</span> <span class="o">=</span> <span class="n">elemObj</span><span class="o">.</span><span class="n">getTransform</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">transObj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">transObjs</span><span class="p">[</span><span class="n">compID</span><span class="p">]</span> <span class="o">=</span> <span class="n">transObj</span>

            <span class="c1"># Write material cards from TACS MaterialProperties class</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">matObj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">matObjs</span><span class="p">):</span>
                <span class="n">matID</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">matObj</span><span class="o">.</span><span class="n">setNastranID</span><span class="p">(</span><span class="n">matID</span><span class="p">)</span>
                <span class="n">newBDFInfo</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="n">matID</span><span class="p">]</span> <span class="o">=</span> <span class="n">matObj</span><span class="o">.</span><span class="n">generateBDFCard</span><span class="p">()</span>

            <span class="c1"># Write property/element cards from TACSConstitutive/TACSElement classes</span>
            <span class="n">curCoordID</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">compID</span><span class="p">,</span> <span class="n">conObj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conObjs</span><span class="p">):</span>
                <span class="n">propID</span> <span class="o">=</span> <span class="n">conObj</span><span class="o">.</span><span class="n">getNastranID</span><span class="p">()</span>
                <span class="n">propCard</span> <span class="o">=</span> <span class="n">conObj</span><span class="o">.</span><span class="n">generateBDFCard</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">propCard</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Copy property comment (may include component name info)</span>
                    <span class="c1"># Make sure to remove comment `$` from string</span>
                    <span class="n">propCard</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">propID</span><span class="p">]</span><span class="o">.</span><span class="n">comment</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="c1"># Add property card to BDF</span>
                    <span class="n">newBDFInfo</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">propID</span><span class="p">]</span> <span class="o">=</span> <span class="n">propCard</span>
                <span class="n">elemIDs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getGlobalElementIDsForComps</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">compID</span><span class="p">],</span> <span class="n">nastranOrdering</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="c1"># Convert any transform objects to nastran COORD2R cards, if necessary</span>
                <span class="n">transObj</span> <span class="o">=</span> <span class="n">transObjs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">compID</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">transObj</span><span class="p">,</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">ShellRefAxisTransform</span>
                <span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transObj</span><span class="p">,</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">SpringRefFrameTransform</span><span class="p">):</span>
                    <span class="n">coordID</span> <span class="o">=</span> <span class="n">curCoordID</span>
                    <span class="n">origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transObj</span><span class="p">,</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">SpringRefFrameTransform</span><span class="p">):</span>
                        <span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span> <span class="o">=</span> <span class="n">transObj</span><span class="o">.</span><span class="n">getRefAxes</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">vec1</span> <span class="o">=</span> <span class="n">transObj</span><span class="o">.</span><span class="n">getRefAxis</span><span class="p">()</span>
                        <span class="n">vec2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                    <span class="c1"># Add COORD2R card to BDF</span>
                    <span class="n">pn</span><span class="o">.</span><span class="n">cards</span><span class="o">.</span><span class="n">coordinate_systems</span><span class="o">.</span><span class="n">define_coord_e123</span><span class="p">(</span>
                        <span class="n">newBDFInfo</span><span class="p">,</span>
                        <span class="s2">&quot;CORD2R&quot;</span><span class="p">,</span>
                        <span class="n">coordID</span><span class="p">,</span>
                        <span class="n">origin</span><span class="p">,</span>
                        <span class="n">xaxis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">vec1</span><span class="p">),</span>
                        <span class="n">xzplane</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">vec2</span><span class="p">),</span>
                        <span class="n">add</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">curCoordID</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># We just need the ref vector for these types</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">transObj</span><span class="p">,</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">BeamRefAxisTransform</span>
                <span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transObj</span><span class="p">,</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">SpringRefAxisTransform</span><span class="p">):</span>
                    <span class="n">vec</span> <span class="o">=</span> <span class="n">transObj</span><span class="o">.</span><span class="n">getRefAxis</span><span class="p">()</span>
                    <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
                <span class="c1"># Otherwise, there&#39;s no transform associated with this element, use default</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coordID</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># Copy and update element cards</span>
                <span class="k">for</span> <span class="n">elemID</span> <span class="ow">in</span> <span class="n">elemIDs</span><span class="p">:</span>
                    <span class="c1"># Create copy of card</span>
                    <span class="n">newCard</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">elemID</span><span class="p">])</span>
                    <span class="c1"># Copy element comment (may include component name info)</span>
                    <span class="c1"># Make sure to remove comment `$` from string</span>
                    <span class="n">newCard</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">elemID</span><span class="p">]</span><span class="o">.</span><span class="n">comment</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="c1"># Update element coordinate frame info, if necessary</span>
                    <span class="k">if</span> <span class="s2">&quot;CQUAD&quot;</span> <span class="ow">in</span> <span class="n">newCard</span><span class="o">.</span><span class="n">type</span> <span class="ow">or</span> <span class="s2">&quot;CTRI&quot;</span> <span class="ow">in</span> <span class="n">newCard</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                        <span class="n">newCard</span><span class="o">.</span><span class="n">theta_mcid</span> <span class="o">=</span> <span class="n">coordID</span>
                    <span class="k">elif</span> <span class="s2">&quot;CBAR&quot;</span> <span class="ow">in</span> <span class="n">newCard</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                        <span class="n">newCard</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">vec</span>
                        <span class="n">newCard</span><span class="o">.</span><span class="n">g0</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">elif</span> <span class="s2">&quot;CBEAM&quot;</span> <span class="ow">in</span> <span class="n">newCard</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                        <span class="n">newCard</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">vec</span>
                        <span class="n">newCard</span><span class="o">.</span><span class="n">g0</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="k">if</span> <span class="n">propCard</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s2">&quot;PBEAM&quot;</span><span class="p">:</span>
                            <span class="c1"># TACS wrote out a PBAR card that we must convert</span>
                            <span class="n">newPropCard</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">pn</span><span class="o">.</span><span class="n">cards</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">beam</span><span class="o">.</span><span class="n">PBEAM_init_from_empty</span><span class="p">()</span>
                            <span class="p">)</span>
                            <span class="n">newPropCard</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">propCard</span><span class="o">.</span><span class="n">Area</span><span class="p">()</span>
                            <span class="n">newPropCard</span><span class="o">.</span><span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">propCard</span><span class="o">.</span><span class="n">I11</span><span class="p">()</span>
                            <span class="n">newPropCard</span><span class="o">.</span><span class="n">i2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">propCard</span><span class="o">.</span><span class="n">I22</span><span class="p">()</span>
                            <span class="n">newPropCard</span><span class="o">.</span><span class="n">i12</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">propCard</span><span class="o">.</span><span class="n">I12</span><span class="p">()</span>
                            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">propCard</span><span class="p">,</span> <span class="s2">&quot;J&quot;</span><span class="p">):</span>
                                <span class="n">newPropCard</span><span class="o">.</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">propCard</span><span class="o">.</span><span class="n">J</span><span class="p">()</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">newPropCard</span><span class="o">.</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">propCard</span><span class="o">.</span><span class="n">j</span>
                            <span class="n">newPropCard</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="n">propCard</span><span class="o">.</span><span class="n">comment</span>
                            <span class="n">propCard</span> <span class="o">=</span> <span class="n">newPropCard</span>
                    <span class="k">elif</span> <span class="s2">&quot;CROD&quot;</span> <span class="ow">in</span> <span class="n">newCard</span><span class="o">.</span><span class="n">type</span> <span class="ow">and</span> <span class="n">propCard</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s2">&quot;PROD&quot;</span><span class="p">:</span>
                        <span class="c1"># TACS wrote out a PBAR card that we must convert</span>
                        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">propCard</span><span class="p">,</span> <span class="s2">&quot;J&quot;</span><span class="p">):</span>
                            <span class="n">J</span> <span class="o">=</span> <span class="n">propCard</span><span class="o">.</span><span class="n">J</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">J</span> <span class="o">=</span> <span class="n">propCard</span><span class="o">.</span><span class="n">j</span>
                        <span class="n">newPropCard</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">cards</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">rods</span><span class="o">.</span><span class="n">PROD</span><span class="p">(</span>
                            <span class="n">propCard</span><span class="o">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">propCard</span><span class="o">.</span><span class="n">mid</span><span class="p">,</span> <span class="n">propCard</span><span class="o">.</span><span class="n">Area</span><span class="p">(),</span> <span class="n">J</span>
                        <span class="p">)</span>
                        <span class="n">newBDFInfo</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">propID</span><span class="p">]</span> <span class="o">=</span> <span class="n">newPropCard</span>
                        <span class="n">newPropCard</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="n">propCard</span><span class="o">.</span><span class="n">comment</span>
                        <span class="n">propCard</span> <span class="o">=</span> <span class="n">newPropCard</span>
                    <span class="k">elif</span> <span class="n">newCard</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;CBUSH&quot;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transObj</span><span class="p">,</span> <span class="n">tacs</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">SpringRefAxisTransform</span><span class="p">):</span>
                            <span class="n">newCard</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">vec</span>
                            <span class="n">newCard</span><span class="o">.</span><span class="n">g0</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">newCard</span><span class="o">.</span><span class="n">cid</span> <span class="o">=</span> <span class="n">coordID</span>
                    <span class="c1"># Add element card to bdf</span>
                    <span class="n">newBDFInfo</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">elemID</span><span class="p">]</span> <span class="o">=</span> <span class="n">newCard</span>

            <span class="c1"># Copy over masses elements</span>
            <span class="k">for</span> <span class="n">massCard</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">masses</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">elemID</span> <span class="o">=</span> <span class="n">massCard</span><span class="o">.</span><span class="n">eid</span>
                <span class="c1"># We&#39;ll have to create a new CONM2 card in case the point mass is associated with tacs dvs</span>
                <span class="k">if</span> <span class="n">massCard</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;CONM2&quot;</span><span class="p">:</span>
                    <span class="n">nodeID</span> <span class="o">=</span> <span class="n">massCard</span><span class="o">.</span><span class="n">nid</span>
                    <span class="n">elemObj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getElementObjectForElemID</span><span class="p">(</span>
                        <span class="n">elemID</span><span class="p">,</span> <span class="n">nastranOrdering</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>
                    <span class="n">conObj</span> <span class="o">=</span> <span class="n">elemObj</span><span class="o">.</span><span class="n">getConstitutive</span><span class="p">()</span>
                    <span class="n">M</span> <span class="o">=</span> <span class="n">conObj</span><span class="o">.</span><span class="n">evalMassMatrix</span><span class="p">()</span>
                    <span class="n">mass</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">I11</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">15</span><span class="p">])</span>
                    <span class="n">I22</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">18</span><span class="p">])</span>
                    <span class="n">I33</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">20</span><span class="p">])</span>
                    <span class="c1"># Nastran uses negative convention for POI&#39;s</span>
                    <span class="n">I12</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">16</span><span class="p">])</span>
                    <span class="n">I13</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">17</span><span class="p">])</span>
                    <span class="n">I23</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">19</span><span class="p">])</span>
                    <span class="n">newBDFInfo</span><span class="o">.</span><span class="n">add_conm2</span><span class="p">(</span>
                        <span class="n">elemID</span><span class="p">,</span> <span class="n">nodeID</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="p">[</span><span class="n">I11</span><span class="p">,</span> <span class="n">I12</span><span class="p">,</span> <span class="n">I22</span><span class="p">,</span> <span class="n">I13</span><span class="p">,</span> <span class="n">I23</span><span class="p">,</span> <span class="n">I33</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="c1"># CONM1&#39;s can&#39;t be updated by TACS, so we can just copy the original value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newBDFInfo</span><span class="o">.</span><span class="n">masses</span><span class="p">[</span><span class="n">elemID</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">massCard</span><span class="p">)</span>
                <span class="c1"># Copy over comments</span>
                <span class="n">newBDFInfo</span><span class="o">.</span><span class="n">masses</span><span class="p">[</span><span class="n">elemID</span><span class="p">]</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="n">massCard</span><span class="o">.</span><span class="n">comment</span>

            <span class="c1"># Copy over rigid elements</span>
            <span class="n">newBDFInfo</span><span class="o">.</span><span class="n">rigid_elements</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">rigid_elements</span><span class="p">)</span>

            <span class="c1"># Add case control deck for loads</span>
            <span class="n">caseConLines</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;TITLE = TACS Analysis Set&quot;</span><span class="p">,</span>
                <span class="s2">&quot;ECHO = NONE&quot;</span><span class="p">,</span>
                <span class="s2">&quot;DISPLACEMENT(PLOT) = ALL&quot;</span><span class="p">,</span>
                <span class="s2">&quot;SPCFORCE(PLOT) = ALL&quot;</span><span class="p">,</span>
                <span class="s2">&quot;OLOAD(PLOT) = ALL&quot;</span><span class="p">,</span>
                <span class="s2">&quot;FORCE(PLOT,CORNER) = ALL&quot;</span><span class="p">,</span>
                <span class="s2">&quot;STRESS(PLOT,CORNER) = ALL&quot;</span><span class="p">,</span>
                <span class="s2">&quot;SPC = 1&quot;</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="n">newBDFInfo</span><span class="o">.</span><span class="n">case_control_deck</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">case_control_deck</span><span class="o">.</span><span class="n">CaseControlDeck</span><span class="p">(</span>
                <span class="n">caseConLines</span>
            <span class="p">)</span>
            <span class="c1"># Set solution type to static (101)</span>
            <span class="n">newBDFInfo</span><span class="o">.</span><span class="n">sol</span> <span class="o">=</span> <span class="mi">101</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">newBDFInfo</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># All procs should wait for root</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="c1"># Append forces from problem classes</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">problem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">problems</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">tacs</span><span class="o">.</span><span class="n">problems</span><span class="o">.</span><span class="n">StaticProblem</span><span class="p">):</span>
                <span class="n">loadCase</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">problem</span><span class="o">.</span><span class="n">writeLoadToBDF</span><span class="p">(</span><span class="n">newBDFInfo</span><span class="p">,</span> <span class="n">loadCase</span><span class="p">)</span>

        <span class="c1"># Write out BDF file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">newBDFInfo</span><span class="o">.</span><span class="n">write_bdf</span><span class="p">(</span>
                <span class="n">fileName</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">is_double</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">write_header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">enddata</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

        <span class="c1"># All procs should wait for root</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span></div>


<div class="viewcode-block" id="pyTACS.createAdjacencyConstraint">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.createAdjacencyConstraint">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">createAdjacencyConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new AdjacencyConstraint for calculating</span>
<span class="sd">        design variable differences across adjacent components.</span>
<span class="sd">        This constraint can be used to ensure that the design variables</span>
<span class="sd">        do not change too abruptly across components.</span>
<span class="sd">        The formulation is a linear constraint that takes the following form:</span>

<span class="sd">        c = dv_i - dv_j</span>

<span class="sd">        Where dv_i and dv_j are two design variables in adjacent components.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name to assign constraint.</span>
<span class="sd">        options : dict</span>
<span class="sd">            Class-specific options to pass to AdjacencyConstraint instance (case-insensitive).</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        constraint : tacs.constraints.AdjacencyConstraint</span>
<span class="sd">            AdjacencyConstraint object used for calculating constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">constr</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">AdjacencyConstraint</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputViewer</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="p">,</span>
            <span class="n">options</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Set with original design vars and coordinates, in case they have changed</span>
        <span class="n">constr</span><span class="o">.</span><span class="n">setDesignVars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">constr</span><span class="o">.</span><span class="n">setNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xpts0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">constr</span></div>


<div class="viewcode-block" id="pyTACS.createDVConstraint">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.createDVConstraint">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">createDVConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new DVConstraint for calculating linear constraints based</span>
<span class="sd">        on design variables within the same component.</span>

<span class="sd">        The constraints are of the form:</span>

<span class="sd">            c = a_0 * dv_0 + a_1 * dv_1 + ... + a_n * dv_n</span>

<span class="sd">        Where which design variables to include (dv_0, dv_1, etc.)</span>
<span class="sd">        and the corresponding weights (a_0, a_1, etc.) are defined by the user.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name to assign constraint.</span>
<span class="sd">        options : dict</span>
<span class="sd">            Class-specific options to pass to DVConstraint instance (case-insensitive).</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        constraint : tacs.constraints.DVConstraint</span>
<span class="sd">            DVConstraint object used for calculating constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">constr</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">DVConstraint</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputViewer</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="p">,</span>
            <span class="n">options</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Set with original design vars and coordinates, in case they have changed</span>
        <span class="n">constr</span><span class="o">.</span><span class="n">setDesignVars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">constr</span><span class="o">.</span><span class="n">setNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xpts0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">constr</span></div>


<div class="viewcode-block" id="pyTACS.createPanelLengthConstraint">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.createPanelLengthConstraint">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">createPanelLengthConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new PanelLengthConstraint for enforcing that the panel</span>
<span class="sd">        length DV values passed to components match the actual panel lengths.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name to assign constraint.</span>
<span class="sd">        options : dict</span>
<span class="sd">            Class-specific options to pass to DVConstraint instance (case-insensitive).</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        constraint : tacs.constraints.PanelLengthConstraint</span>
<span class="sd">            PanelLengthConstraint object used for calculating constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">constr</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">PanelLengthConstraint</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputViewer</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="p">,</span>
            <span class="n">options</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Set with original design vars and coordinates, in case they have changed</span>
        <span class="n">constr</span><span class="o">.</span><span class="n">setDesignVars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">constr</span><span class="o">.</span><span class="n">setNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xpts0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">constr</span></div>


<div class="viewcode-block" id="pyTACS.createVolumeConstraint">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.createVolumeConstraint">[docs]</a>
    <span class="nd">@postinitialize_method</span>
    <span class="k">def</span> <span class="nf">createVolumeConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new VolumeConstraint for constraining the size of a closed volume.</span>
<span class="sd">        Only shell and solid elements are supported for this constraint.</span>
<span class="sd">        For shell elements, the enclosed volume MUST be manifold and water-tight (no missing/internal faces).</span>
<span class="sd">        The formulation is a nonlinear constraint based on the nodal coordinates.</span>

<span class="sd">        A common example of this is ensuring enough volume in the wingbox for fuel:</span>

<span class="sd">            vol_wing &gt;= vol_fuel</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name to assign constraint.</span>
<span class="sd">        options : dict</span>
<span class="sd">            Class-specific options to pass to VolumeConstraint instance (case-insensitive).</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        constraint : tacs.constraints.VolumeConstraint</span>
<span class="sd">            VolumeConstraint object used for calculating constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">constr</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">VolumeConstraint</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputViewer</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="p">,</span>
            <span class="n">options</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Set with original design vars and coordinates, in case they have changed</span>
        <span class="n">constr</span><span class="o">.</span><span class="n">setDesignVars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">constr</span><span class="o">.</span><span class="n">setNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xpts0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">constr</span></div>


<div class="viewcode-block" id="pyTACS.getNumComponents">
<a class="viewcode-back" href="../../pytacs/pytacs_module.html#tacs.pytacs.pyTACS.getNumComponents">[docs]</a>
    <span class="k">def</span> <span class="nf">getNumComponents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return number of components (property) groups found in bdf.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nComp : int</span>
<span class="sd">            Number of components in model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nComp</span></div>


    <span class="k">def</span> <span class="nf">_createOutputGroups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Automatically determine how to split out the output file</span>
<span class="sd">        for easier viewing&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fam</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="p">):</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compDescripts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;familySeparator&quot;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fam</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Uniqify them and sort</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fam</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fam</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compFam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;intc&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="p">):</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compDescripts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;familySeparator&quot;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compFam</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fam</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_createOutputViewer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method to create the appropriate output viewer</span>
<span class="sd">        (TACSToFH5 object) for TACS.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Depending on the user-supplied options generate the</span>
        <span class="c1"># write_flag</span>
        <span class="n">write_flag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;writeConnectivity&quot;</span><span class="p">):</span>
            <span class="n">write_flag</span> <span class="o">|=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">OUTPUT_CONNECTIVITY</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;writeNodes&quot;</span><span class="p">):</span>
            <span class="n">write_flag</span> <span class="o">|=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">OUTPUT_NODES</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;writeDisplacements&quot;</span><span class="p">):</span>
            <span class="n">write_flag</span> <span class="o">|=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">OUTPUT_DISPLACEMENTS</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;writeStrains&quot;</span><span class="p">):</span>
            <span class="n">write_flag</span> <span class="o">|=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">OUTPUT_STRAINS</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;writeStresses&quot;</span><span class="p">):</span>
            <span class="n">write_flag</span> <span class="o">|=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">OUTPUT_STRESSES</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;writeExtras&quot;</span><span class="p">):</span>
            <span class="n">write_flag</span> <span class="o">|=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">OUTPUT_EXTRAS</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;writeLoads&quot;</span><span class="p">):</span>
            <span class="n">write_flag</span> <span class="o">|=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">OUTPUT_LOADS</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;writeCoordinateFrame&quot;</span><span class="p">):</span>
            <span class="n">write_flag</span> <span class="o">|=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">OUTPUT_COORDINATES</span>

        <span class="c1"># Create actual viewer</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;outputElement&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">elementType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getOption</span><span class="p">(</span><span class="s2">&quot;outputElement&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Set the output type based on the first element in the model</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">getElementObjectForElemID</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nastranOrdering</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">elementType</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">getElementType</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">outputViewer</span> <span class="o">=</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">ToFH5</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="p">,</span> <span class="n">elementType</span><span class="p">,</span> <span class="n">write_flag</span><span class="p">)</span>

        <span class="c1"># Set the names of each of the output families</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fam</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputViewer</span><span class="o">.</span><span class="n">setComponentName</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fam</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_getCompIDs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">inList</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal method to return the component IDs mathing</span>
<span class="sd">        information in inList&quot;&quot;&quot;</span>

        <span class="c1"># First recursively flatten the inList in case it was nested:</span>
        <span class="n">inList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatten</span><span class="p">(</span><span class="n">inList</span><span class="p">)</span>

        <span class="c1"># Neste list container for compIDs</span>
        <span class="n">compIDs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Look at each item in list (which is a list because of the *)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">inList</span><span class="p">:</span>
            <span class="n">compIDs</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="c1"># Integers are easy, just check if in bounds and add:</span>
                <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">item</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="p">:</span>
                    <span class="n">compIDs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_TACSWarning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Trying to add component ID of </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">, which</span><span class="se">\</span>
<span class="s2">                    is out of the range 0 &lt;= compID &lt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># This is a little inefficient here; loop over</span>
                <span class="c1"># self.compDescripts and see if &#39;item&#39; (a string) in</span>
                <span class="c1"># part of the description. if so add.</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">compDescripts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">():</span>
                        <span class="n">compIDs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_TACSWarning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unidentifiable information given for &#39;include&#39;</span><span class="se">\</span>
<span class="s2">                or &#39;exclude&#39;. Valid data are integers 0 &lt;= i &lt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="si">}</span><span class="s2">, or </span><span class="se">\</span>
<span class="s2">                strings.&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;and&quot;</span><span class="p">:</span>
            <span class="c1"># First convert each entry to a set:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">compIDs</span><span class="p">)):</span>
                <span class="n">compIDs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">compIDs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># We want to go through and take only the intersection of</span>
            <span class="c1"># each of the sets we have found:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">compIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">compIDs</span><span class="p">)):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">compIDs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">compIDs</span> <span class="o">=</span> <span class="n">tmp</span>

        <span class="c1"># Finally, convert to a list</span>
        <span class="n">compIDs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatten</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">compIDs</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">compIDs</span>

    <span class="k">def</span> <span class="nf">_createElements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elemCallBack</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create all the constitutive objects by calling the</span>
<span class="sd">        userSupplied or default callback function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elemCallBack : callable</span>
<span class="sd">            Element callback function provided by user or pyTACS</span>
<span class="sd">            to set up TACS element objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nComp</span><span class="p">):</span>
            <span class="c1"># Get a list of compDescripts to help the user</span>
            <span class="n">compDescript</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compDescripts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">numElements</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elemDescripts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="c1"># TACS component ID</span>
            <span class="n">compID</span> <span class="o">=</span> <span class="n">i</span>
            <span class="c1"># Nastran property ID</span>
            <span class="n">propID</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bdfInfo</span><span class="o">.</span><span class="n">property_ids</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Call the user function</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">elemCallBack</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span><span class="p">,</span>
                <span class="n">compID</span><span class="p">,</span>
                <span class="n">compDescript</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">elemDescripts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">globalDVs</span><span class="p">,</span>
                <span class="n">propID</span><span class="o">=</span><span class="n">propID</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># For maximum flexibility, multiple pieces of information</span>
            <span class="c1"># can be returned. At a minimum, the element objects</span>
            <span class="c1"># must be returned!</span>

            <span class="c1"># Note: If two objects are returned, the</span>
            <span class="c1"># first one is used as the element object list and the</span>
            <span class="c1"># second one is treated as a scale list for the added dvs.</span>

            <span class="c1"># Check that result is an element object instance or .</span>
            <span class="n">numFoundElements</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">scaleList</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">elemObjects</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
                    <span class="c1"># Iterable item, the scale list:</span>
                    <span class="n">scaleList</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
                    <span class="n">scaleList</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="c1"># Don&#39;t know what it is:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_TACSWarning</span><span class="p">(</span>
                        <span class="s2">&quot;Could not identify objects returned </span><span class="se">\</span>
<span class="s2">                    from elemCallBack. Valid return objects are: </span><span class="se">\</span>
<span class="s2">                    A list of TACS element objects (required, first), </span><span class="se">\</span>
<span class="s2">                    an iterable object </span><span class="se">\</span>
<span class="s2">                    (eg, list or array) containing the scaling parameters </span><span class="se">\</span>
<span class="s2">                    for the added design variables (optional, second). The </span><span class="se">\</span>
<span class="s2">                    string representation of the offending object is: </span><span class="se">\</span>
<span class="s2">                    &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span>
                        <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">elemObjects</span> <span class="o">=</span> <span class="n">result</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elemObjects</span><span class="p">,</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">Element</span><span class="p">):</span>
                <span class="c1"># There was only one element, recast it as a list and continue</span>
                <span class="n">elemObjects</span> <span class="o">=</span> <span class="p">[</span><span class="n">elemObjects</span><span class="p">]</span>
                <span class="n">numFoundElements</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elemObjects</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># Multiple elements were returned, count how many</span>
                <span class="k">for</span> <span class="nb">object</span> <span class="ow">in</span> <span class="n">elemObjects</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">tacs</span><span class="o">.</span><span class="n">TACS</span><span class="o">.</span><span class="n">Element</span><span class="p">):</span>
                        <span class="n">numFoundElements</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Object of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span><span class="si">}</span><span class="s2"> returned in elemCallBack function &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;is not a valid TACS element object. The </span><span class="se">\</span>
<span class="s2">                               string representation of the offending object is: </span><span class="se">\</span>
<span class="s2">                               &#39;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                        <span class="p">)</span>

            <span class="k">if</span> <span class="n">numFoundElements</span> <span class="o">!=</span> <span class="n">numElements</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unexpected number of element objects </span><span class="se">\</span>
<span class="s2">                    returned from user-supplied elemCallBack function. </span><span class="se">\</span>
<span class="s2">                    </span><span class="si">{</span><span class="n">numElements</span><span class="si">}</span><span class="s2"> element types (</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elemDescripts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="si">}</span><span class="s2">) are contained in Component </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, </span><span class="se">\</span>
<span class="s2">                    but </span><span class="si">{</span><span class="n">numFoundElements</span><span class="si">}</span><span class="s2"> element objects were returned by elemCallback.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Now determine the number of design variables. This is</span>
            <span class="c1"># NOT as simple as just getting the number of design</span>
            <span class="c1"># variables; Not all variables added in the conObject are</span>
            <span class="c1"># &#39;new&#39; variables, some of the variable number may have</span>
            <span class="c1"># been already used.</span>
            <span class="n">newVars</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">elemObject</span> <span class="ow">in</span> <span class="n">elemObjects</span><span class="p">:</span>
                <span class="n">dvs</span> <span class="o">=</span> <span class="n">elemObject</span><span class="o">.</span><span class="n">getDesignVarNums</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dvs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># We will also check if the user screwed up. That is</span>
                    <span class="c1"># make sure that for added variables, the are</span>
                    <span class="c1"># continuous starting at self.dvNum</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">dvs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">var</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span><span class="p">:</span>
                            <span class="n">newVars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>

            <span class="c1"># Remove repeated dv nums from list</span>
            <span class="n">newVars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">newVars</span><span class="p">)</span>
            <span class="n">newVars</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newVars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Now the length of newVars must the same as</span>
                <span class="c1"># newVars[-1]-newVars[0] + 1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">newVars</span><span class="p">)</span> <span class="o">==</span> <span class="n">newVars</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">newVars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                        <span class="s2">&quot;Inconsistent design variables detected. &quot;</span>
                        <span class="s2">&quot;The added design variables are not continuous.&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot; The added design variables are </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">newVars</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>

            <span class="c1"># Finally, increment the dv counter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dvNum</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">newVars</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newVars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">scaleList</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">scaleList</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">newVars</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Make sure that the scaleList is the correct length.</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scaleList</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">newVars</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_TACSWarning</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;An incorrect number of scale variables </span><span class="se">\</span>
<span class="s2">                        were returned. There were </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">newVars</span><span class="p">)</span><span class="si">}</span><span class="s2"> variables added, but only </span><span class="se">\</span>
<span class="s2">                        </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">scaleList</span><span class="p">)</span><span class="si">}</span><span class="s2"> scale variables returned. The scale for these </span><span class="se">\</span>
<span class="s2">                        variables will be set to 1.0. The scale variables are </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">scaleList</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                        <span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">scaleList</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">newVars</span><span class="p">)))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">scaleList</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">scaleList</span><span class="p">)</span>

            <span class="c1"># Loop through every element type in this component,</span>
            <span class="c1"># there may be multiple (e.g CQUAD4 + CTRIA3)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">elemObject</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">elemObjects</span><span class="p">):</span>
                <span class="c1"># Set component-specific family id</span>
                <span class="n">elemObject</span><span class="o">.</span><span class="n">setComponentNum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compFam</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="c1"># Set each of the elements for this component</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meshLoader</span><span class="o">.</span><span class="n">setElementObject</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">elemObject</span><span class="p">)</span>
                <span class="c1"># set varsPerNode</span>
                <span class="n">elemVarsPerNode</span> <span class="o">=</span> <span class="n">elemObject</span><span class="o">.</span><span class="n">getVarsPerNode</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">varsPerNode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">varsPerNode</span> <span class="o">=</span> <span class="n">elemVarsPerNode</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">varsPerNode</span> <span class="o">!=</span> <span class="n">elemVarsPerNode</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TACSError</span><span class="p">(</span>
                        <span class="s2">&quot;Model references elements with differing numbers of variables per node &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">varsPerNode</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">elemVarsPerNode</span><span class="si">}</span><span class="s2">). &quot;</span>
                        <span class="s2">&quot;All elements must use same number of variables to be compatible.&quot;</span>
                    <span class="p">)</span>

        <span class="c1"># If varsPerNode still hasn&#39;t been set (because there were no elements added in the callback)</span>
        <span class="c1"># Default to 6</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">varsPerNode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">varsPerNode</span> <span class="o">=</span> <span class="mi">6</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">TACS  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">tacs.pytacs</a></li> 
      </ul>
    </div>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>

  </body>
</html>